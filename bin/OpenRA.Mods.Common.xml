<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenRA.Mods.Common</name>
    </assembly>
    <members>
        <member name="M:OpenRA.Mods.Common.Activities.Enter.TickInner(OpenRA.Actor,OpenRA.Traits.Target@,System.Boolean)">
            <summary>
            Called early in the activity tick to allow subclasses to update state.
            Call Cancel(self, true) if it is no longer valid to enter.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Activities.Enter.TryStartEnter(OpenRA.Actor,OpenRA.Actor)">
            <summary>
            Called when the actor is ready to transition from approaching to entering the target actor.
            Return true to start entering, or false to wait in the WaitingToEnter state.
            Call Cancel(self, true) before returning false if it is no longer valid to enter.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Activities.Enter.OnEnterComplete(OpenRA.Actor,OpenRA.Actor)">
            <summary>
            Called when the actor has entered the target actor.
            Actor will be Killed/Disposed or they will enter/exit unharmed.
            Depends on either the EnterBehaviour of the actor or the requirements of an overriding function.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Activities.FindAndDeliverResources.ClosestHarvestablePos(OpenRA.Actor)">
            <summary>
            Finds the closest harvestable pos between the current position of the harvester
            and the last order location.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Activities.MoveCooldownHelper">
            <summary>
            Activities that queue move activities via <see cref="T:OpenRA.Mods.Common.Traits.IMove"/> can use this helper to decide
            when moves with blocked destinations should be retried and to apply a cooldown between repeated moves.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Activities.MoveCooldownHelper.RetryIfDestinationBlocked">
            <summary>
            If a move failed because the destination was blocked, indicates if we should try again.
            When true, <see cref="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Tick(System.Boolean)"/> will return null when the destination is blocked, after the cooldown has been applied.
            When false, <see cref="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Tick(System.Boolean)"/> will return true to indicate the activity should give up and complete.
            Defaults to false.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Cooldown">
            <summary>
            The cooldown delay in ticks. After a move with a blocked destination, the cooldown will be started.
            Whilst the cooldown is in effect, <see cref="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Tick(System.Boolean)"/> will return false.
            After the cooldown finishes, <see cref="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Tick(System.Boolean)"/> will return null to allow activity logic to resume.
            This cooldown is important to avoid lag spikes caused by pathfinding every tick because the destination is unreachable.
            Defaults to (20, 31).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.NotifyMoveQueued">
            <summary>
            Call this when queuing a move activity.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Activities.MoveCooldownHelper.Tick(System.Boolean)">
            <summary>
            Call this method within the <see cref="M:OpenRA.Activities.Activity.Tick(OpenRA.Actor)"/> method. It will return a tick result.
            </summary>
            <param name="targetIsHiddenActor">If the target is a hidden actor, forces the result to be true, once the move has completed.</param>
            <returns>A result that should be returned from the calling Tick method.
            A non-null result should be returned immediately.
            On a null result, the method should continue with it's usual logic and perform any desired moves.</returns>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.IDockClient.DockClientManager">
            <summary>When null, the client should act as if it can dock but never do.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockClient.CanDock(OpenRA.Primitives.BitSet{OpenRA.Mods.Common.Traits.DockType},System.Boolean)">
            <summary>Are we allowed to dock.</summary>
            <remarks>
            Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.
            Function should only be called from within <see cref="T:OpenRA.Mods.Common.Traits.IDockClient"/> or <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/>.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockClient.CanDockAt(OpenRA.Actor,OpenRA.Mods.Common.Traits.IDockHost,System.Boolean,System.Boolean)">
            <summary>Are we allowed to dock to this <paramref name="host"/>.</summary>
            <remarks>
            Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.
            Function should only be called from within <see cref="T:OpenRA.Mods.Common.Traits.IDockClient"/> or <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/>.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockClient.CanQueueDockAt(OpenRA.Actor,OpenRA.Mods.Common.Traits.IDockHost,System.Boolean,System.Boolean)">
            <summary>Are we allowed to give a docking order for this <paramref name="host"/>.</summary>
            <remarks>
            Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.
            Function should only be called from within <see cref="T:OpenRA.Mods.Common.Traits.IDockClient"/> or <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/>.
            </remarks>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.IDockHost.IsEnabledAndInWorld">
            <summary>Use this function instead of ConditionalTrait.IsTraitDisabled.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockHost.IsDockingPossible(OpenRA.Actor,OpenRA.Mods.Common.Traits.IDockClient,System.Boolean)">
            <summary>Can this <paramref name="client"/> dock at this <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/>.</summary>
            <remarks>
            Does not check <see cref="T:OpenRA.Mods.Common.Traits.DockType"/>.
            Does not check if <see cref="T:OpenRA.Mods.Common.Traits.IDockClient"/> is enabled.
            Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockHost.QueueMoveActivity(OpenRA.Activities.Activity,OpenRA.Actor,OpenRA.Actor,OpenRA.Mods.Common.Traits.DockClientManager,OpenRA.Mods.Common.Activities.MoveCooldownHelper)">
            <summary>If <paramref name="client"/> is not in range of <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/> queues a child move activity and returns true. If in range returns false.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IDockHost.QueueDockActivity(OpenRA.Activities.Activity,OpenRA.Actor,OpenRA.Actor,OpenRA.Mods.Common.Traits.DockClientManager)">
            <summary>Should be called when in range of <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.EditorActorDropdown.#ctor(System.String,System.Int32,System.Func{OpenRA.Mods.Common.Traits.EditorActorPreview,System.Collections.Generic.Dictionary{System.String,System.String}},System.Func{OpenRA.Mods.Common.Traits.EditorActorPreview,System.Collections.Generic.Dictionary{System.String,System.String},System.String},System.Action{OpenRA.Mods.Common.Traits.EditorActorPreview,System.String})">
            <summary>
            Creates dropdown for editing actor's metadata with dynamically created items.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.BlockedByActor">
            <summary>
            When performing locomotion or pathfinding related checks,
            determines whether the blocking rules will be applied when encountering other actors.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Traits.BlockedByActor.None">
            <summary>
            Actors on the map are ignored, as if they were not present.
            An actor can only be blocked by impassable terrain.
            An actor can never be blocked by other actors. The blocking rules will never be evaluated.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable">
            <summary>
            Actors on the map that are moving, or moveable &amp; allied are ignored.
            An actor is Immovable is any of the following applies:
            <list type="bullet">
            <item>Lacks the <see cref="T:OpenRA.Mods.Common.Traits.Mobile"/> trait.</item>
            <item>The <see cref="T:OpenRA.Mods.Common.Traits.Mobile"/> trait has <see cref="P:OpenRA.Mods.Common.Traits.ConditionalTrait`1.IsTraitDisabled"/> or
            <see cref="P:OpenRA.Mods.Common.Traits.PausableConditionalTrait`1.IsTraitPaused"/> as true.</item>
            <item>The <see cref="T:OpenRA.Mods.Common.Traits.Mobile"/> trait has <see cref="P:OpenRA.Mods.Common.Traits.Mobile.IsImmovable"/> as true.</item>
            </list>
            Note the above definition means an actor can be Movable, but may not be Moving, i.e. it is Stationary.
            Actors are allied if their owners have the <see cref="F:OpenRA.Traits.PlayerRelationship.Ally"/> relationship.
            An actor can be blocked by impassable terrain.
            An actor can be blocked by immovable actors *if* they are deemed as blocking by the blocking rules.
            An actor can be blocked by an actor capable of moving, if it is not an ally and *if* they are deemed as
            blocking by the blocking rules.
            An actor can never be blocked by an allied actor capable of moving, even if the other actor is stationary.
            An actor can never be blocked by a moving actor.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Traits.BlockedByActor.Stationary">
            <summary>
            Actors on the map that are moving are ignored.
            An actor is moving if both of the following apply:
            <list type="bullet">
            <item>It is a Moveable actor (see <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/>).</item>
            <item><see cref="P:OpenRA.Mods.Common.Traits.Mobile.CurrentMovementTypes"/> contains the flag <see cref="F:OpenRA.Mods.Common.Traits.MovementType.Horizontal"/>.</item>
            </list>
            Otherwise the actor is deemed to be Stationary.
            An actor can be blocked by impassable terrain.
            An actor can be blocked by immovable actors and stationary actors *if* they are deemed as blocking by the
            blocking rules.
            An actor can never be blocked by a moving actor.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Traits.BlockedByActor.All">
            <summary>
            Actors on the map are not ignored.
            An actor can be blocked by impassable terrain.
            An actor can be blocked by immovable actors, stationary actors and moving actors *if* they are deemed as
            blocking by the blocking rules.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IPathFinder.FindPathToTargetCell(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from multiple possible sources to target.
            Returned path is *reversed* and given target to source.
            The shortest path between a source and the target is returned.
            </summary>
            <remarks>Path searches are not guaranteed to by symmetric,
            the source and target locations cannot be swapped.
            Call <see cref="M:OpenRA.Mods.Common.Traits.IPathFinder.FindPathToTargetCells(OpenRA.Actor,OpenRA.CPos,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)"/> instead.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IPathFinder.FindPathToTargetCells(OpenRA.Actor,OpenRA.CPos,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from source to multiple possible targets.
            Returned path is *reversed* and given target to source.
            The shortest path between the source and a target is returned.
            </summary>
            <remarks>Path searches are not guaranteed to by symmetric,
            the source and target locations cannot be swapped.
            Call <see cref="M:OpenRA.Mods.Common.Traits.IPathFinder.FindPathToTargetCell(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)"/> instead.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IPathFinder.FindPathToTargetCellByPredicate(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},System.Func{OpenRA.CPos,System.Boolean},OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from multiple possible sources, whilst searching for an acceptable target.
            Returned path is *reversed* and given target to source.
            The shortest path between a source and a discovered target is returned.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IPathFinder.PathExistsForLocomotor(OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines if a path exists between source and target.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            This would apply for any actor using the given <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/>.
            </summary>
            <remarks>Path searches are not guaranteed to by symmetric,
            the source and target locations cannot be swapped.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.IPathFinder.PathMightExistForLocomotorBlockedByImmovable(OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines if a path exists between source and target.
            Terrain and immovable actors are taken into account,
            i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> was given.
            Implementations are permitted to only account for a subset of actors, for performance.
            This would apply for any actor using the given <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/>.
            </summary>
            <remarks>Path searches are not guaranteed to by symmetric,
            the source and target locations cannot be swapped.
            If this method returns false, there is guaranteed to be no path.
            If it returns true, there *might* be a path.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.SupportPowerDecision.GetAttractiveness(OpenRA.WPos,OpenRA.Player)">
            <summary>Evaluates the attractiveness of a position according to all considerations.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.SupportPowerDecision.GetAttractiveness(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Player)">
            <summary>Evaluates the attractiveness of a group of actors according to all considerations.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.SupportPowerDecision.Consideration">
            <summary>Makes up part of a decision, describing how to evaluate a target.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.SupportPowerDecision.Consideration.GetAttractiveness(OpenRA.Actor,OpenRA.Traits.PlayerRelationship,OpenRA.Player)">
            <summary>Evaluates a single actor according to the rules defined in this consideration.</summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.BotModules.Squads.Squad.Target">
            <summary>
            Target location to attack. This will be either the targeted actor,
            or a position close to that actor sufficient to get within weapons range.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Traits.BotModules.Squads.Squad.TargetActor">
            <summary>
            Actor that is targeted, for any actor based checks. Use <see cref="P:OpenRA.Mods.Common.Traits.BotModules.Squads.Squad.Target"/> for a targeting location.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.BotModules.Squads.Squad.IsTargetValid(OpenRA.Actor)">
            <summary>
            Checks the target is still valid, and updates the <see cref="P:OpenRA.Mods.Common.Traits.BotModules.Squads.Squad.Target"/> location if it is still valid.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.BotModules.Squads.GroundStateBase.Leader(OpenRA.Mods.Common.Traits.BotModules.Squads.Squad)">
            <summary>
            Elects a unit to lead the squad, other units in the squad will regroup to the leader if they start to spread out.
            The leader remains the same unless a new one is forced or the leader is no longer part of the squad.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.SupportPowerBotModule.FindCoarseAttackLocationToSupportPower(OpenRA.Mods.Common.Traits.SupportPowerInstance)">
            <summary>Scans the map in chunks, evaluating all actors in each.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.SupportPowerBotModule.FindFineAttackLocationToSupportPower(OpenRA.Mods.Common.Traits.SupportPowerInstance,OpenRA.CPos,System.Int32)">
            <summary>Detail scans an area, evaluating positions.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TransformsIntoDockClient.CanDockAt(OpenRA.Actor,System.Boolean)">
            <summary>Clone of <see cref="M:OpenRA.Mods.Common.Traits.DockClientManager.CanDockAt(OpenRA.Actor,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TransformsIntoDockClient.CanQueueDockAt(OpenRA.Actor,System.Boolean,System.Boolean)">
            <summary>Clone of <see cref="M:OpenRA.Mods.Common.Traits.DockClientManager.CanQueueDockAt(OpenRA.Actor,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.CaptureManager.CanTarget(OpenRA.Mods.Common.Traits.CaptureManager)">
            <summary>Should only be called from the captor's CaptureManager.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.CaptureManager.CanTarget(OpenRA.Traits.FrozenActor)">
            <summary>Should only be called from the captor CaptureManager.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.CaptureManager.StartCapture(OpenRA.Mods.Common.Traits.CaptureManager,OpenRA.Mods.Common.Traits.Captures@)">
            <summary>
            Called by CaptureActor when the activity is ready to enter and capture the target.
            This method grants the capturing conditions on the captor and target and returns
            true if the captor is able to start entering or false if it needs to wait.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.CaptureManager.CancelCapture(OpenRA.Actor,OpenRA.Mods.Common.Traits.CaptureManager)">
            <summary>
            Called by CaptureActor when the activity finishes or is cancelled
            This method revokes the capturing conditions on the captor and target
            and resets any capturing progress.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.Carryall.CarryableOffset">
            <summary>Offset between the carryall's and the carried actor's CenterPositions.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.ConditionalTraitInfo">
            <summary>Use as base class for *Info to subclass of ConditionalTrait. (See ConditionalTrait.)</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.ConditionalTrait`1">
            <summary>
            Abstract base for enabling and disabling trait using conditions.
            Requires basing *Info on ConditionalTraitInfo and using base(info) constructor.
            TraitEnabled will be called at creation if the trait starts enabled or does not use conditions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.ExternalCondition.TryRevokeCondition(OpenRA.Actor,System.Object,System.Int32)">
            <summary>Revokes the external condition with the given token if it was granted by this trait.</summary>
            <returns><c>true</c> if the now-revoked condition was originally granted by this trait.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.GrantConditionOnDeploy.Deploy">
            <summary>Play deploy sound and animation.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.GrantConditionOnDeploy.Undeploy">
            <summary>Play undeploy sound and animation and after that revoke the condition.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.PausableConditionalTraitInfo">
            <summary>Use as base class for *Info to subclass of PausableConditionalTrait. (See PausableConditionalTrait.)</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.PausableConditionalTrait`1">
            <summary>
            Abstract base for enabling and disabling trait using conditions.
            Requires basing *Info on PausableConditionalTraitInfo and using base(info) constructor.
            TraitResumed will be called at creation if the trait starts not paused or does not have a pause condition.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.ReserveHost(OpenRA.Actor,OpenRA.Mods.Common.Traits.IDockHost)">
            <summary>In addition returns true if reservation was successful or we have already been reserved at <paramref name="host"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.CanDock(OpenRA.Primitives.BitSet{OpenRA.Mods.Common.Traits.DockType},System.Boolean)">
            <summary>Do we have an enabled client with matching <paramref name="type"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.CanDock(OpenRA.Actor,System.Boolean)">
            <summary>Does this <paramref name="target"/> contain at least one enabled <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/> with matching <see cref="T:OpenRA.Mods.Common.Traits.DockType"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.CanDockAt(OpenRA.Actor,OpenRA.Mods.Common.Traits.IDockHost,System.Boolean,System.Boolean)">
            <summary>Can we dock to this <paramref name="host"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.CanDockAt(OpenRA.Actor,System.Boolean,System.Boolean)">
            <summary>Can we dock to this <paramref name="target"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.CanQueueDockAt(OpenRA.Actor,System.Boolean,System.Boolean)">
            <summary>Can we dock to this <paramref name="target"/>.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.ClosestDock(OpenRA.Mods.Common.Traits.IDockHost,OpenRA.Primitives.BitSet{OpenRA.Mods.Common.Traits.DockType},System.Boolean,System.Boolean)">
            <summary>Find the closest viable <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/>.</summary>
            <remarks>If <paramref name="type"/> is not set, scans all clients. Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.AvailableDockHosts(OpenRA.Actor,OpenRA.Primitives.BitSet{OpenRA.Mods.Common.Traits.DockType},System.Boolean,System.Boolean)">
            <summary>Get viable <see cref="T:OpenRA.Mods.Common.Traits.IDockHost"/>'s on the <paramref name="target"/>.</summary>
            <remarks>If <paramref name="type"/> is not set, checks all clients. Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.DockClientManager.AvailableDockClients(OpenRA.Primitives.BitSet{OpenRA.Mods.Common.Traits.DockType},System.Boolean)">
            <summary>Get clients of matching <paramref name="type"/>.</summary>
            <remarks>Does not check if <see cref="T:OpenRA.Mods.Common.Traits.DockClientManager"/> is enabled.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.MobileInfo.CanEnterCell(OpenRA.World,OpenRA.Actor,OpenRA.CPos,OpenRA.Traits.SubCell,OpenRA.Actor,OpenRA.Mods.Common.Traits.BlockedByActor)">
            <summary>
            Note: If the target <paramref name="cell"/> has any free subcell, the value of <paramref name="subCell"/> is ignored.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.ScriptTagsInit">
            <summary>Allows mappers to 'tag' actors with arbitrary strings that may have meaning in their scripts.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.ActorMapWorldExts.GetCustomMovementLayers(OpenRA.World)">
            <summary>
            Returns an array of custom movement layers.
            The <see cref="P:OpenRA.Mods.Common.Traits.ICustomMovementLayer.Index"/> of a layer is used to index into this array.
            This array may contain null entries for layers which are not present in the world.
            This array is guaranteed to have a length of at least one. Index 0 is always null.
            Index 0 is kept null as layer 0 is used for the ground layer, consumers can combine
            the ground layer and custom layers into a single array for easy indexing.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.CreateMapPlayersInfo.OpenRA#Traits#ICreatePlayersInfo#CreateServerPlayers(OpenRA.MapPreview,OpenRA.Network.Session,System.Collections.Generic.List{OpenRA.GameInformation.Player},OpenRA.Support.MersenneTwister)">
            <summary>
            Returns a list of GameInformation.Players that matches the indexing of ICreatePlayers.CreatePlayers.
            Non-playable players appear as null in the list.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.EditorResourceLayer.CalculateCellDensity(OpenRA.Mods.Common.Traits.ResourceLayerContents,OpenRA.CPos)">
            <summary>
            Matches the logic in <see cref="T:OpenRA.Mods.Common.Traits.ResourceLayer"/> trait.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.HierarchicalPathFinderOverlay.Locomotor">
            <summary>
            The Locomotor selected in the UI which the overlay will display.
            If null, will show the overlays for the currently selected units.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.Traits.HierarchicalPathFinderOverlay.Check">
            <summary>
            The blocking check selected in the UI which the overlay will display.
            </summary>
        </member>
        <member name="E:OpenRA.Mods.Common.Traits.Locomotor.CellCostChanged">
            <summary>
            Raised when the movement cost for a cell changes, providing the old and new costs.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.Locomotor.IsBlockedBy(OpenRA.Actor,OpenRA.Actor,OpenRA.Actor,OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Mods.Common.Traits.CellFlag)">
            <remarks>This logic is replicated in <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorIsBlocking(OpenRA.Actor)"/> and
            <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorCellIsBlocking(OpenRA.Actor,OpenRA.CPos)"/>. If this method is updated please update those as
            well.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.Locomotor.UpdateCellBlocking(OpenRA.CPos)">
            <remarks>This logic is replicated in <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorIsBlocking(OpenRA.Actor)"/> and
            <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorCellIsBlocking(OpenRA.Actor,OpenRA.CPos)"/>. If this method is updated please update those as
            well.</remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.PathFinder.FindPathToTargetCell(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from multiple possible sources to target.
            Returned path is *reversed* and given target to source.
            The shortest path between a source and the target is returned.
            </summary>
            <remarks>
            <para>
            It is allowed for an actor to occupy an inaccessible space and move out of it if another adjacent cell is
            accessible, but it is not allowed to move into an inaccessible target space. Therefore it is vitally
            important to not mix up the source and target locations. A path can exist from an inaccessible source space
            to an accessible target space, but if those parameters as swapped then no path can exist.
            </para>
            <para>
            Searches that provide multiple source cells are slower than those than provide only a single source cell,
            as optimizations are possible for the single source case. Use searches from multiple source cells
            sparingly.
            </para>
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.PathFinder.FindPathToTargetCells(OpenRA.Actor,OpenRA.CPos,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from source to multiple possible targets.
            Returned path is *reversed* and given target to source.
            The shortest path between the source and a target is returned.
            </summary>
            <remarks>
            <para>
            It is allowed for an actor to occupy an inaccessible space and move out of it if another adjacent cell is
            accessible, but it is not allowed to move into an inaccessible target space. Therefore it is vitally
            important to not mix up the source and target locations. A path can exist from an inaccessible source space
            to an accessible target space, but if those parameters as swapped then no path can exist.
            </para>
            <para>
            Searches that provide multiple target cells are slower than those than provide only a single target cell,
            as optimizations are possible for the single target case. Use searches to multiple target cells
            sparingly.
            </para>
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.PathFinder.FindPathToTargetCellByPredicate(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},System.Func{OpenRA.CPos,System.Boolean},OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)">
            <summary>
            Calculates a path for the actor from multiple possible sources, whilst searching for an acceptable target.
            Returned path is *reversed* and given target to source.
            The shortest path between a source and a discovered target is returned.
            </summary>
            <remarks>
            Searches with this method are slower than <see cref="M:OpenRA.Mods.Common.Traits.PathFinder.FindPathToTargetCell(OpenRA.Actor,System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean)"/> due to the need to search for
            and discover an acceptable target cell. Use this search sparingly.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.PathFinder.PathExistsForLocomotor(OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines if a path exists between source and target.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            This would apply for any actor using the given <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/>.
            </summary>
            <remarks>
            It is allowed for an actor to occupy an inaccessible space and move out of it if another adjacent cell is
            accessible, but it is not allowed to move into an inaccessible target space. Therefore it is vitally
            important to not mix up the source and target locations. A path can exist from an inaccessible source space
            to an accessible target space, but if those parameters as swapped then no path can exist.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.PathFinder.PathMightExistForLocomotorBlockedByImmovable(OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines if a path exists between source and target.
            Terrain and a *subset* of immovable actors are taken into account,
            i.e. as if a subset of <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> was given.
            This would apply for any actor using the given <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/>.
            </summary>
            <remarks>
            It is allowed for an actor to occupy an inaccessible space and move out of it if another adjacent cell is
            accessible, but it is not allowed to move into an inaccessible target space. Therefore it is vitally
            important to not mix up the source and target locations. A path can exist from an inaccessible source space
            to an accessible target space, but if those parameters as swapped then no path can exist.
            As only a subset of immovable actors are taken into account,
            this method can return false positives, indicating a path might exist where none is possible.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.ResourceClaimLayer.TryClaimCell(OpenRA.Actor,OpenRA.CPos)">
            <summary>
            Attempt to reserve the resource in a cell for the given actor.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.ResourceClaimLayer.CanClaimCell(OpenRA.Actor,OpenRA.CPos)">
            <summary>
            Returns false if the cell is already reserved by an allied actor.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.ResourceClaimLayer.RemoveClaim(OpenRA.Actor)">
            <summary>
            Release the last resource claim made by this actor.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan">
            <summary>
            Holds the shape of a path being planned out in the map editor.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.#ctor(OpenRA.CPos)">
            <summary>Start a new path with a given first point.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithStart(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>Return a copy, modifying the start direction.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithEnd(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>Return a copy, modifying the end direction.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithLoop(System.Boolean)">
            <summary>Return a copy, modifying whether the path is looped.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithRallyAppended(OpenRA.CPos)">
            <summary>Return a copy, with a rally appended.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithRallyRemoved(System.Int32)">
            <summary>Return a copy, with the rally at index removed.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithRallyReplaced(System.Int32,OpenRA.CPos)">
            <summary>Return a copy, with the rally at index replace/moved.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.WithRallyInserted(System.Int32,OpenRA.CPos)">
            <summary>Return a copy, with a rally inserted before index.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.Moved(OpenRA.CVec)">
            <summary>Return a copy, with everything translated by offset.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.Reversed">
            <summary>Return a copy, with rallies reversed and directions swapped.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.Points">
            <summary>
            Convert the rally points into a sequence of unit-space CPos points, suitable for
            processing with TilingPath.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Traits.TilingPathTool.PathPlan.PointsWithRallyIndex">
            <summary>
            Convert the rally points into a sequence of unit-space CPos points and their
            associated latest rally index. For loops, the last rally index is the number of the
            rallies.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.ActorIndex">
            <summary>
            Maintains an index of actors in the world.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.ActorIndex.OwnerAndNames">
            <summary>
            Maintains an index of actors in the world that
            are owned by a given <see cref="T:OpenRA.Player"/>
            and have one of the given <see cref="F:OpenRA.ActorInfo.Name"/>.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.ActorIndex.NamesAndTrait`1">
            <summary>
            Maintains an index of actors in the world that
            have one of the given <see cref="F:OpenRA.ActorInfo.Name"/>
            and have the trait with info of type <typeparamref name="TTraitInfo"/>.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.ActorIndex.OwnerAndNamesAndTrait`1">
            <summary>
            Maintains an index of actors in the world that
            are owned by a given <see cref="T:OpenRA.Player"/>,
            have one of the given <see cref="F:OpenRA.ActorInfo.Name"/>
            and have the trait with info of type <typeparamref name="TTraitInfo"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.ActorInitActorReference.Actor(OpenRA.World)">
            <summary>
            The lazy value may reference other actors that have not been created
            yet, so must not be resolved from the actor constructor or Created method.
            Use a FrameEndTask or wait until it is actually needed.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.ColorMixerWidget.Set(OpenRA.Primitives.Color)">
            <summary>
            Set the color picker to nearest valid color to the given value.
            The saturation and brightness may be adjusted.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.Logic.LobbyUtils.SplitOnFirstToken(System.String,System.String)">
            <summary>Splits a string into two parts on the first instance of a given token.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Widgets.CommandBarLogic">
            <summary>Contains all functions that are unit-specific.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.VideoPlayerWidget.LoadAndPlay(System.String)">
            <summary>
            Tries to load a video from the specified file and play it. Does nothing if the file name matches the already loaded video.
            </summary>
            <param name="filename">Name of the file, including the extension.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.VideoPlayerWidget.LoadAndPlayAsync(System.String,System.Action)">
            <summary>
            Tries to load a video from the specified file and play it. Does nothing if the file name matches the already loaded video.
            </summary>
            <param name="filename">Name of the file, including the extension.</param>
            <param name="after">Action to perform after the video ends.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.VideoPlayerWidget.Play(OpenRA.Video.IVideo)">
            <summary>
            Plays the given <see cref="T:OpenRA.Video.IVideo"/>.
            </summary>
            <param name="video">An <see cref="T:OpenRA.Video.IVideo"/> instance.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.Widgets.WidgetUtils.DrawPanel(OpenRA.Primitives.Rectangle,OpenRA.Graphics.Sprite[])">
            <summary>
            Fill a rectangle with sprites defining a panel layout.
            Draw order is center, borders, corners to allow mods to define fancy border and corner overlays.
            </summary>
            <param name="bounds">Rectangle to fill.</param>
            <param name="sprites">Nine sprites defining the panel: TL, T, TR, L, C, R, BL, B, BR.</param>
        </member>
        <member name="T:OpenRA.Mods.Common.EditorBrushes.EditorBlit">
            <summary>
            Core implementation for EditorActions which overwrite a region of the map (such as
            copy-paste).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.EditorBrushes.EditorBlit.CopyRegionContents(OpenRA.Map,OpenRA.Mods.Common.Traits.EditorActorLayer,OpenRA.Mods.Common.Traits.IResourceLayer,OpenRA.CellRegion,OpenRA.Mods.Common.EditorBrushes.MapBlitFilters,System.Collections.Generic.IReadOnlySet{OpenRA.CPos})">
            <summary>
            Returns an EditorBlitSource containing the map contents for a given region.
            If a mask is supplied, only tiles and actors (fully or partially) overlapping the mask
            are included in the EditorBlitSource.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.EditorBrushes.EditorBlit.GetBlitSourceMask(OpenRA.Mods.Common.EditorBrushes.EditorBlitSource,OpenRA.CVec)">
            <summary>
            Find the set of cells within an EditorBlitSource that are actually occupied by a
            BlitTile or actor. Note that all tiles must be inside the CellRegion, and actors must
            be at least partially inside the CellRegion. If an actor partially lies outside of the
            CellRegion, only cells within the CellRegion are included in the output set.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.FileFormats.Blast.Decompress(System.IO.Stream,System.IO.Stream,System.Action{System.Int64,System.Int64})">
            <summary>PKWare Compression Library stream.</summary>
            <param name="input">Compressed input stream.</param>
            <param name="output">Stream to write the decompressed output.</param>
            <param name="onProgress">Progress callback, invoked with (read bytes, written bytes).</param>
        </member>
        <member name="T:OpenRA.Mods.Common.Graphics.EditorSelectionAnnotationRenderable">
            <summary>
            Render the current editor area selection or paste region.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.ActorPlan">
            <summary>Description of an actor to add to a map.</summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.ActorPlan.WPosCenterLocation">
            <summary>
            WPos representation of actor's center.
            For example, A 1x2 actor on a Rectangular grid will have +WVec(0, 512, 0)
            offset to its WPosLocation.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.#ctor(OpenRA.Map,OpenRA.ActorReference)">
            <summary>
            Create an ActorPlan from a reference. The referenced actor becomes owned.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.#ctor(OpenRA.Map,System.String)">
            <summary>
            Create an ActorPlan containing a new Neutral-owned actor of the given type.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.Clone">
            <summary>
            Create a cloned actor plan, cloning the underlying ActorReference.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.Footprint">
            <summary>
            The footprint of the actor (influenced by its location).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.AlignFootprint">
            <summary>
            Relocates the actor such that the top-most, left-most footprint
            square is at (0, 0).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.WVecCenterOffset">
            <summary>
            <para>
            Return a WVec center offset (from its WPosLocation) for the actor.
            </para>
            <para>
            For example, for a 1x2 actor on a Rectangular grid, this would be WVec(0, 512, 0).
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.ActorPlan.MaxSpan">
            <summary>Return the larger of the width or height of the actor's footprint.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.AreSameShape``2(OpenRA.CellLayer{``0},OpenRA.CellLayer{``1})">
            <summary>Return true iff a and b have the same grid type and size.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Center``1(OpenRA.CellLayer{``0})">
            <summary>
            Returns the half-way point between the centers of the top-left (first) and bottom-right
            (last) MPos cells. This will either lie in the exact center of a cell, an edge between
            two cells, or a corner between four cells. Note that this might not fit all reasonable
            or intuitive definitions of a map center, but has convenient properties.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Radius``1(OpenRA.CellLayer{``0})">
            <summary>
            Return the radius of the largest circle that can be contained in the cell layer.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CornerToWPos(OpenRA.CPos,OpenRA.MapGridType)">
            <summary>Get the WPos of the -X-Y corner of a CPos cell.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.WPosToCorner(OpenRA.WPos,OpenRA.MapGridType)">
            <summary>Get the closest -X-Y corner of a CPos cell to a WPos.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CVecToWVec(OpenRA.CVec,OpenRA.MapGridType)">
            <summary>Get the WVec representing the same translation as the given CVec.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CPosToWPos(OpenRA.CPos,OpenRA.MapGridType)">
            <summary>Get the WPos center of a CPos cell.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.WPosToCPos(OpenRA.WPos,OpenRA.MapGridType)">
            <summary>
            Find the CPos cell in which a WPos position lies. WPos positions on
            an edge or corner match the CPos with higher X and/or Y positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.MPosToWPos(OpenRA.MPos,OpenRA.MapGridType)">
            <summary>Get the WPos center of an MPos cell.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.WPosToMPos(OpenRA.WPos,OpenRA.MapGridType)">
            <summary>
            Find the MPos cell in which a WPos position lies. WPos positions on
            an edge or corner match the CPos (not necessarily MPos) with higher
            X and/or Y positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.ToMatrixPoints``1(System.Collections.Generic.IEnumerable{OpenRA.CPos[]},OpenRA.CellLayer{``0})">
            <summary>
            Translates CPos-like positions to zero-based positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.FromMatrixPoints``1(System.Collections.Generic.IEnumerable{OpenRA.int2[]},OpenRA.CellLayer{``0})">
            <summary>
            Translates zero-based positions to CPos-like positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.OverCircle``1(OpenRA.CellLayer{``0},OpenRA.WPos,OpenRA.WDist,System.Boolean,System.Action{OpenRA.MPos,OpenRA.CPos,OpenRA.WPos,System.Int64})">
            <summary>
            <para>
            Run an action over the inside or outside of a circle of given center and radius in
            world coordinates. The action is called with cells' MPos, CPos, WPos center, and the
            squared distance to the WPos center from the circle's center.
            If outside is true, the action is run for cells outside of the circle instead of the
            inside.
            </para>
            <para>
            A cell is inside the circle if its center is &lt;= wRadius from wCenter.
            Coordinates outside of the CellLayer are ignored.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Entries``1(OpenRA.CellLayer{``0})">
            <summary>
            Return a linear copy of all entries in a CellLayer, ordered v * width + u, similar to
            MPos(0, 0), MPos(1, 0), MPos(2, 0), ..., MPos(0, 1), MPos(1, 1), MPos(2, 1), ...
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CalibrateQuantileInPlace(OpenRA.CellLayer{System.Int32},System.Int32,System.Int32,System.Int32)">
            <summary>
            Uniformally add to or subtract from all cells such that the quantile (count/outOf) has at the target value.
            For example, (target: 0, count: 25, outOf: 75) where there are 401 cells would mean
            that 100 cells are no greater than 0, 300 cells are no less than 0, and at least 1 cell
            is 0.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CalibratedBooleanThreshold(OpenRA.CellLayer{System.Int32},System.Int32,System.Int32)">
            <summary>
            Return a boolean CellLayer where true correlates with the largest values in the input,
            such that the fraction of true cells is at least (but approximately) count/outOf.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CellBounds(OpenRA.Primitives.Size,OpenRA.MapGridType)">
            <summary>
            Get the smallest CPos rectangle that contains all cells for the specified grid.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CellBounds``1(OpenRA.CellLayer{``0})">
            <summary>
            Get the smallest CPos rectangle that contains all cells in a CellLayer.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.CellBounds(OpenRA.Map)">
            <summary>
            Get the smallest CPos rectangle that contains all cells in a map.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.FromMatrix``1(OpenRA.CellLayer{``0},OpenRA.Mods.Common.MapGenerator.Matrix{``0},System.Boolean)">
            <summary>
            Copies a CPos-aligned Matrix into a CellLayer. Depending on the grid type, this may
            discard data for cells that don't exist in the CellLayer.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.ToMatrix``1(OpenRA.CellLayer{``0},``0)">
            <summary>
            Copies a CellLayer into a CPos-aligned Matrix. Depending on the grid type, this may
            fill the matrix with some default values for cells that don't exist in the CellLayer.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.BordersToPoints(OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Boolean})">
            <summary>Wrapper around MatrixUtils.BordersToPoints in CPos space.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.ChebyshevRoom(OpenRA.CellLayer{System.Int32},OpenRA.CellLayer{System.Boolean},System.Boolean)">
            <summary>Wrapper around MatrixUtils.ChebyshevRoom in CPos space.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.WalkingDistances(OpenRA.CellLayer{OpenRA.WDist},OpenRA.CellLayer{System.Boolean},System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.WDist)">
            <summary>
            Wrapper around MatrixUtils.WalkingDistance in CPos space.
            Returns world distances (1024ths).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.FindRandomBest``1(OpenRA.CellLayer{``0},OpenRA.Support.MersenneTwister,System.Comparison{``0})">
            <summary>
            Rank all cell values and select the best (greatest compared) value.
            If there are equally good best candidates, choose one at random.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.PickWeighted(OpenRA.CellLayer{System.Int32},OpenRA.Support.MersenneTwister)">
            <summary>
            Pick a random MPos position in a CellLayer where each cell is a
            selection weight.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.FloodFill``2(OpenRA.CellLayer{``0},System.Collections.Generic.IEnumerable{System.ValueTuple{OpenRA.CPos,``1}},System.Func{OpenRA.CPos,``1,System.Nullable{``1}},System.Collections.Immutable.ImmutableArray{OpenRA.CVec})">
            <summary>
            <para>
            Perform a generic flood fill starting at seeds <c>[(cpos, prop), ...]</c>.
            </para>
            <para>
            For each point being considered for fill, <c>filler(cpos, prop)</c> is
            called with the current position (cpos) and propagation value (prop).
            filler should return the value to be propagated or null if not to be
            propagated. Propagation happens to all neighbours (offsets) defined
            by spread, regardless of whether they have previously been visited,
            so filler is responsible for terminating propagation by returning
            nulls. Usually, <c>Direction.Spread4CVec</c> or <c>Direction.Spread8CVec</c>
            is appropriate as a spread pattern.
            </para>
            <para>
            filler should capture and manipulate any necessary input and output
            arrays.
            </para>
            <para>
            Each call to filler will have either an equal or greater
            growth/propagation distance from their seed value than all calls
            before it. (You can think of this as them being called in ordered
            growth layers.)
            </para>
            <para>
            Note that filler may be called multiple times for the same spot,
            perhaps with different propagation values. Within the same
            growth/propagation distance, filler will be called from values
            propagated from earlier seeds before values propagated from later
            seeds.
            </para>
            <para>
            filler is not called for positions outside of cellLayer EXCEPT for
            points being processed as seed values.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.SimpleFloodFill(OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Boolean},System.Action{OpenRA.CPos},System.Collections.Immutable.ImmutableArray{OpenRA.CVec})">
            <summary>
            Simple flood fill that propagates, starting from seed cells, throughout a masked area.
            The fillAction is run once (in a consistent order) for each filled cell.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Intersect(System.Collections.Generic.IEnumerable{OpenRA.CellLayer{System.Boolean}})">
            <summary>Return logical AND / conjunction / intersection of layers.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Subtract(System.Collections.Generic.IEnumerable{OpenRA.CellLayer{System.Boolean}})">
            <summary>
            Return the difference of layers. Each cell is true if and only if something appears
            only in the first layer.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Clone``1(OpenRA.CellLayer{``0})">
            <summary>Create a shallow copy of a CellLayer.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Create``1(OpenRA.Map,System.Func{OpenRA.MPos,``0})">
            <summary>Create and initialize a CellLayer according to the given function.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.CellLayerUtils.Create``1(OpenRA.Map,System.Func{OpenRA.CPos,``0})">
            <summary>Create and initialize a CellLayer according to the given function.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Direction">
            <summary>
            Utilities for simple directions and adjacency. Note that coordinate systems might not agree
            as to which directions are conceptually left/right or up/down.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.None">
            <summary>No direction.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.R">
            <summary>+X ("right").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.RD">
            <summary>+X+Y ("right down").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.D">
            <summary>+Y ("down").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.LD">
            <summary>-X+Y ("left down").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.L">
            <summary>-X ("left").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.LU">
            <summary>-X-Y ("left up").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.U">
            <summary>-Y ("up").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Direction.RU">
            <summary>+X-Y ("right up").</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MR">
            <summary>Bitmask right.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MRD">
            <summary>Bitmask right-down.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MD">
            <summary>Bitmask down.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MLD">
            <summary>Bitmask left-down.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.ML">
            <summary>Bitmask left.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MLU">
            <summary>Bitmask left-up.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MU">
            <summary>Bitmask up.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionMask.MRU">
            <summary>Bitmask right-up.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread4D">
            <summary>Adjacent offsets with directions, excluding diagonals.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread4">
            <summary>Adjacent offsets, excluding diagonals.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread4CVec">
            <summary>
            Adjacent offsets, excluding diagonals. Assumes that CVec(1, 0)
            corresponds to Direction.R.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread8D">
            <summary>Adjacent offsets with directions, including diagonals.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread8">
            <summary>Adjacent offsets, including diagonals.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.DirectionExts.Spread8CVec">
            <summary>
            Adjacent offsets, including diagonals. Assumes that CVec(1, 0)
            corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ToInt2(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>Convert a non-none direction to an int2 offset.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ToCVec(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>
            Convert a non-none direction to a CVec offset. Assumes that
            CVec(1, 0) corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ToWVec(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>
            Convert a non-none direction to a WVec offset. Assumes that
            WVec(1, 0, 0) corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromOffset(System.Int32,System.Int32)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a direction.
            The direction is based purely on the signs of the inputs.
            Supplying a zero-offset will throw.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ClosestFrom(System.Int32,System.Int32)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a direction.
            The direction with the closest angle wins. Keep inputs to 1000000 or less.
            Supplying a zero-offset will throw.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromInt2(OpenRA.int2)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a direction.
            Supplying a zero-offset will throw.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromCVec(OpenRA.CVec)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a direction.
            Supplying a zero-offset will throw. Assumes that CVec(1, 0)
            corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ClosestFromCVec(OpenRA.CVec)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a direction.
            Supplying a zero-offset will throw. Assumes that CVec(1, 0)
            corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromOffsetNonDiagonal(System.Int32,System.Int32)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a non-diagonal direction.
            Supplying a zero-offset will throw.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromInt2NonDiagonal(OpenRA.int2)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a
            non-diagonal direction. Supplying a zero-offset will throw.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.FromCVecNonDiagonal(OpenRA.CVec)">
            <summary>
            Convert an offset (of arbitrary non-zero magnitude) to a
            non-diagonal direction. Supplying a zero-offset will throw. Assumes
            that CVec(1, 0) corresponds to Direction.R.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.Reverse(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>Return the opposite direction.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionExts.ToMask(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>Converts the direction to a mask value.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionMaskExts.Count(OpenRA.Mods.Common.MapGenerator.DirectionMask)">
            <summary>Count the number of set bits (directions) in a direction mask.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionMaskExts.ToDirection(OpenRA.Mods.Common.MapGenerator.DirectionMask)">
            <summary>Finds the only direction set in a direction mask or returns None.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.DirectionMaskExts.IsDiagonal(OpenRA.Mods.Common.MapGenerator.Direction)">
            <summary>True if diagonal, false if horizontal/vertical, throws otherwise.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Matrix`1">
            <summary>
            A fixed-size 2D array that can be indexed either linearly or by coordinates.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Matrix`1.Data">
            <summary>Underlying matrix data.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Matrix`1.Size">
            <summary>Matrix dimensions.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.#ctor(OpenRA.int2,`0[])">
            <summary>
            Create a new matrix with the given size and adopt a given array as its backing data.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.#ctor(OpenRA.int2)">
            <summary>Create a new matrix with the given size.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>Create a new matrix with the given size.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Index(OpenRA.int2)">
            <summary>
            Convert a pair of coordinates into an index into Data.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Index(System.Int32,System.Int32)">
            <summary>
            Convert a pair of coordinates into an index into Data.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.XY(System.Int32)">
            <summary>
            Convert a Data index into a pair of coordinates.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.Matrix`1.Item(System.Int32)">
            <summary>Shorthand for Data[i].</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.ContainsXY(OpenRA.int2)">
            <summary>True iff xy is a valid index within the matrix.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.ContainsXY(System.Int32,System.Int32)">
            <summary>True iff (x, y) is a valid index within the matrix.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.ClampXY(OpenRA.int2)">
            <summary>Clamp xy to be the closest index within the matrix.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.ClampXY(System.Int32,System.Int32)">
            <summary>Clamp (x, y) to be the closest index within the matrix.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Transpose">
            <summary>
            Creates a transposed (shallow) copy of the matrix.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Map``1(System.Func{`0,``0})">
            <summary>
            Return a new matrix with the same shape as this one containing the values after being
            transformed by a mapping func.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Fill(`0)">
            <summary>
            Replace all values in the matrix with a given value. Returns this.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Clone">
            <summary>
            Return a shallow clone of this matrix.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Matrix`1.Zip``2(OpenRA.Mods.Common.MapGenerator.Matrix{``0},OpenRA.Mods.Common.MapGenerator.Matrix{``1},System.Func{``0,``1,`0})">
            <summary>
            Combine two same-shape matrices into a new output matrix.
            The zipping function specifies how values are combined.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DumpAdjustment.None">
            <summary>Make no adjustment.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DumpAdjustment.Normalize">
            <summary>Normalize the matrix amplitude to the color range.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DumpAdjustment.Emphasize">
            <summary>
            Normalize the matrix amplitude, but uniformally extend away from zero by a small
            amount to help identify the sign of martix values.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphMode.Identifier">
            <summary>
            The plotted value is the latest sequence touching a cell + 1.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphMode.Gradient">
            <summary>
            The plotted value is the (latest) point index in the (latest) sequence touching a
            cell.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphMode.Accumulate">
            <summary>The plotted value is the count of points touching a cell.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.ColorDump2d(System.String,OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},OpenRA.Mods.Common.MapGenerator.MatrixUtils.DumpAdjustment)">
            <summary>
            <para>
            Debugging method that prints a matrix to stderr using color only (not value listing).
            </para>
            <para>
            Orange &lt; -255, -255 &lt;= Red &lt; 0, Black == 0, 0 &lt; Blue &lt;= 255,
            255 &lt; Cyan. Faint green is used for distance markings.
            </para>
            <para>
            The matrix can optionally be preprocessed for easier visual interpretation using a
            DumpAdjustment.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.EnumDump2d(System.String,OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32})">
            <summary>
            Debugging method that prints a matrix of enum-like values to stderr, where values are
            mapped to one of 27 different colors. Red, green, and blue values represent base-3
            digits of increasing significance. Unmappable values produce white. A corresponding
            letter of the latin alphabet is also written in the right of cells greater than zero.
            E.g., 21_base10 = 210_base3 = bright blue + medium green + no red, letter U.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.Dump2d(System.String,OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean})">
            <summary>
            Debugging method that prints a matrix to stderr.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.Dump2d(System.String,OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32})">
            <summary>
            Debugging method that prints a matrix to stderr.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.Dump2d(System.String,OpenRA.Mods.Common.MapGenerator.Matrix{System.Byte})">
            <summary>
            Debugging method that prints a matrix to stderr.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphPoints(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{OpenRA.int2}},OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphMode)">
            <summary>
            Plot multiple point sequences onto a matrix for debugging visualization. The matrix is
            fit to the shape of all the path.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphPoints(System.Collections.Generic.IEnumerable{OpenRA.int2},OpenRA.Mods.Common.MapGenerator.MatrixUtils.GraphMode)">
            <summary>
            Plot a point sequence onto a matrix for debugging visualization. The matrix is fit to
            the shape of the path.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.FloodFill``1(OpenRA.int2,System.Collections.Generic.IEnumerable{System.ValueTuple{OpenRA.int2,``0}},System.Func{OpenRA.int2,``0,System.Nullable{``0}},System.Collections.Immutable.ImmutableArray{OpenRA.int2})">
            <summary>
            <para>
            Perform a generic flood fill starting at seeds <c>[(xy, prop), ...]</c>.
            </para>
            <para>
            For each point being considered for fill, <c>filler(xy, prop)</c> is
            called with the current position (xy) and propagation value (prop).
            filler should return the value to be propagated or null if not to be
            propagated. Propagation happens to all neighbours (offsets) defined
            by spread, regardless of whether they have previously been visited,
            so filler is responsible for terminating propagation by returning
            nulls. Usually, <c>Direction.SPREAD4</c> or <c>Direction.SPREAD8</c>
            is appropriate as a spread pattern.
            </para>
            <para>
            filler should capture and manipulate any necessary input and output
            arrays.
            </para>
            <para>
            Each call to filler will have either an equal or greater
            growth/propagation distance from their seed value than all calls
            before it. (You can think of this as them being called in ordered
            growth layers.)
            </para>
            <para>
            Note that filler may be called multiple times for the same spot,
            perhaps with different propagation values. Within the same
            growth/propagation distance, filler will be called from values
            propagated from earlier seeds before values propagated from later
            seeds.
            </para>
            <para>
            filler is not called for positions outside of the bounds defined by
            size EXCEPT for points being processed as seed values.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.WalkingDistances(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Collections.Generic.IEnumerable{OpenRA.int2},OpenRA.WDist)">
            <summary>
            <para>
            Compute the in-game walking distances (in 1024ths) from a set of seeds.
            </para>
            <para>
            The output matrix cells will contain either the distance (if reachable) or
            int.MaxValue.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DeflateSpace(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Boolean)">
            <summary>
            <para>
            Shrinkwraps true space to be as far away from false space as possible, preserving
            topology. The result is a kind of rough Voronoi diagram.
            </para>
            <para>
            If the space matrix has width (w, h), the returned matrix will have width (w + 1, h + 1).
            Each value in the returned matrix is a Direction bitmask describing the border structure
            between the cells of the original space matrix.
            </para>
            outsideSpace specified the space values for cells which are outside the space matrix.
            <para>
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.KernelDilateOrErode(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},OpenRA.int2,System.Boolean)">
            <summary>
            Convolute a kernel over a boolean input matrix.
            If dilating, the values specified by the kernel are logically OR-ed.
            If eroding, the values specified by the kernel are logically AND-ed.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BinomialKernel1D(System.Int32)">
            <summary>
            <para>
            Create a one-dimensional binomial kernel of size (2 * radius + 1, 1).
            The total of all kernel cells is 1 &lt;&lt; (radius * 2).
            </para>
            <para>
            This can be applied once, transposed, then applied again to perform a full binomial blur.
            See <see cref="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BinomialBlur(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32)"/>. Maximum supported radius is MaxBinomialKernelRadius.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.KernelFilter(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int64},OpenRA.Mods.Common.MapGenerator.Matrix{System.Int64},OpenRA.int2)">
            <summary>
            Apply an arithmetic convolution of a kernel over an input matrix.
            Cells outside the input matrix take the value of the nearest edge/corner cell.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BinomialBlur(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32)">
            <summary>
            Apply a binomial filter-based blur to a matrix, returning a new matrix. The result is
            somewhat similar to a Gaussian blur. Maximum supported radius is MaxBinomialKernelRadius.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.GridVariance(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32)">
            <summary>
            Finds the local variance of points in a grid (using a square sample area).
            Sample areas are centered on data point corners, so output is (size + 1) * (size + 1).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BooleanBlur(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Blur a boolean matrix using a square kernel, only changing the value
            if the neighborhood is significantly different based on a threshold.
            </para>
            <para>
            The threshold / thresholdOutOf is the size of a majority needed to
            change a value. For example, a threshold of 20 / 25 means, 80% of
            cells must agree to change a cell's value.
            </para>
            <para>
            The space outside of the matrix is treated as if the border was
            extended out.
            </para>
            <para>
            Along with the blurred matrix, the number of changes compared to the
            original is returned.
            </para>
            <para>
            Runtime complexity is approximately O(input.Size) for small radii.
            A more precise complexity would be
              O((input.Size.X + radius) * input.Size.Y +
                input.Size.X            * (input.Size.Y + radius)).
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.RetainThickRegions(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Boolean,System.Int32)">
            <summary>
            Preserves foreground cells that can be safely covered by a (possibly
            out-of-bound) span-by-span square that doesn't touch any !foreground
            cells, and sets any remaining cells to !foreground.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.IntegerInterpolate(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Read a linearly interpolated value between the cells of a matrix. xWeight and yWeight
            must be between 0 and scale inclusive and define the interpolation position
            between x and x+1, and y and y+1.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.CalibrateQuantileInPlace(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32,System.Int32,System.Int32)">
            <summary>
            Uniformally add to or subtract from all cells such that the quantile (count/outOf) has at the target value.
            For example, (target: 0, count: 25, outOf: 75) where there are 401 cells would mean
            that 100 cells are no greater than 0, 300 cells are no less than 0, and at least 1 cell
            is 0.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.CalibratedBooleanThreshold(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32,System.Int32)">
            <summary>
            Return a boolean matrix where true correlates with the largest values in the input,
            such that the fraction of true cells is at least (but approximately) count/outOf.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.ChebyshevRoom(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Boolean)">
            <summary>
            For true cells, gives the Chebyshev distance to the closest false cell.
            For false cells, gives the Chebyshev distance to the closest true cell as a negative.
            outsideValue specifies whether cells outside of the matrix are true or false.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.PointsChirality(OpenRA.int2,System.Collections.Generic.IEnumerable{OpenRA.int2[]})">
            <summary>
            <para>
            Given a set of grid-intersection point arrays, creates a matrix where each cell
            identifies whether the closest points are wrapping around it clockwise or
            counter-clockwise (as defined in MapGenerator.Direction).
            </para>
            <para>
            Positive output values indicate the points are wrapping around it clockwise.
            Negative output values indicate the points are wrapping around it counter-clockwise.
            Outputs can be zero or non-unit magnitude if there are fighting point arrays.
            </para>
            <para>
            If no points are on or close enough to the matrix area, returns null.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BordersToPoints(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean})">
            <summary>
            <para>
            Trace the borders between true and false regions of an input matrix, returning an array
            of point sequences.
            </para>
            <para>
            Point sequences follow the borders keeping the true region on the right-hand side as it
            traces forward. Loops have a matching start and end point.
            </para>
            <para>
            If a mask is supplied, only borders between matrix cells in the mask are considered.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.BooleanBlotch(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>
            Takes an input boolean matrix and performs adjustments to improve the local consistency
            of the true and false regions, making them "blotchy":
            </para>
            <para>
            - Smoothing via thresholded median blurs.
            </para>
            <para>
            - A minimum thickness is enforced for all true/false regions. More formally, eroding
              and then dilating the true or false regions by minimumThickness results in no change.
            </para>
            <para>
            - No grid points connect diagonally-crossing true and false regions. In other words,
              these 2x2 patterns never appear in the output matrix:
            <code>
                10      01
                01  or  10
            </code>
            </para>
            <para>
            A new matrix is returned. The input is unmodified.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DilateThinRegionsInPlaceFull(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Boolean,System.Int32)">
            <summary>
            Repeatedly calls DilateThinRegionsInPlace until no changes are made.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DilateThinRegionsInPlace(OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Boolean,System.Int32)">
            <summary>
            <para>
            If foreground true, finds the thinnest true regions and dilates them.
            If foreground false, finds the thinnest false regions and dilates them.
            Each call only dilates thin regions by one cell's thickness on each border.
            </para>
            <para>
            Only regions with a thickness less than width (in Chebyshev distance) are considered.
            </para>
            <para>
            Returns the number of changes made.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.RemoveStubsFromDirectionMapInPlace(OpenRA.Mods.Common.MapGenerator.Matrix{System.Byte})">
            <summary>Remove links from a direction map that are not reciprocated.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DirectionMapToPaths(OpenRA.Mods.Common.MapGenerator.Matrix{System.Byte})">
            <summary>
            Traces a matrix of directions into a set of point sequences. Each point sequence is
            traced up to but excluding junction points. Paths are traced in both directions. The
            paths in the direction map must be bidirectional and contain no stubs.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.DirectionMapToPathsWithPruning(OpenRA.Mods.Common.MapGenerator.Matrix{System.Byte},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Wrapper around DirectionMapToPaths which iteratively prunes stubs and short paths until
            all paths are at least a minimumLength. Paths shorter than mimimumJunctionSeparation
            sever their neighboring junctions instead of fusing them together.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.MaskPathPoints(System.Collections.Generic.IEnumerable{OpenRA.int2[]},OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean})">
            <summary>
            <para>
            Given a set of point sequences and a stencil mask that defines permitted point positions,
            remove points that are disallowed, splitting or dropping point sequences as needed.
            </para>
            <para>
            The outside of the matrix is considered false (points disallowed).
            </para>
            <para>
            Sequences with fewer than 2 points are dropped.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.OverCircle``1(OpenRA.Mods.Common.MapGenerator.Matrix{``0},OpenRA.int2,System.Int32,System.Boolean,System.Action{OpenRA.int2,System.Int64})">
            <summary>
            <para>
            Run an action over the inside or outside of a circle of given center and radius,
            measured in 1024ths of a cell. The action is called with the int2 cell position (NOT in
            1024ths), and the square of the distance-in-1024ths from the cell's center to the
            circle's center. (Square root and divide by 1024 to get the distance in whole cells.)
            (0, 0) is a corner of the matrix, and (512, 512) is the center of the first cell.
            If outside is true, the action is run for cells outside of the circle instead
            of the inside.
            </para>
            <para>
            A matrix cell is inside the circle if its center is &lt;= radius from center.
            Coordinates outside of the Matrix are ignored.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.NormalizeRangeInPlace(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},System.Int32)">
            <summary>
            Linearly scales the range of values in a matrix to the given target amplitude.
            Returns the modified input. If the input matrix is all zeros, it is left unmodified.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MatrixUtils.FindRandomBest``1(OpenRA.Mods.Common.MapGenerator.Matrix{``0},OpenRA.Support.MersenneTwister,System.Comparison{``0})">
            <summary>
            Rank all cell values and select the best (greatest compared) value.
            If there are equally good best candidates, choose one at random.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.MultiBrushInfo">
            <summary>
            MiniYaml-loaded definition of a MultiBrush. Can be loaded into a MultiBrush once a map is
            available.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment">
            <summary>
            Information about how certain MultiBrushes (like cliffs, beaches, roads) link together.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment.Start">
            <summary>Start type, including a direction. E.g. "Cliff.R".</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment.Inner">
            <summary>
            Inner type. Does not include a direction. E.g. "Cliff".
            A null (absent) inner type implies that both the start and end types can be considered
            valid inner types.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment.End">
            <summary>End type, including a direction. E.g. "Cliff.R".</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment.Points">
            <summary>
            Point sequence, where points are -X-Y corners of template tiles.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrushSegment.#ctor(System.String,System.String,System.String,System.Collections.Immutable.ImmutableArray{OpenRA.CVec})">
            <summary>
            Create a Segment from a point sequence and given start, inner, and end types.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.MultiBrush">
            <summary>A super template that can be used to paint both tiles and actors.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability.None">
            <summary>Area cannot be replaced by a tile or obstructing actor.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability.Tile">
            <summary>Area must be replaced by a different tile, and may optionally be given an actor.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability.Actor">
            <summary>Area must be given an actor, but the underlying tile must not change.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability.Any">
            <summary>Area can be replaced by a tile and/or actor.</summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.MultiBrush.TileRange.DefaultTile">
            <summary>Pick a non-randomized tile.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.TileRange.Pick(OpenRA.Support.MersenneTwister)">
            <summary>
            Pick a (possibly randomized) tile. random can be null to fall back to DefaultTile.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.MultiBrush.Area">
            <summary>Total area covered by the MultiBrush.</summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.MultiBrush.FirstCell">
            <summary>
            The CVec of the first cell covered by the MultiBrush. This is the left-most cell in the
            top-row. Note that this does not necessarily correspond to the top-left corner of the
            rectangular bounds of the MultiBrush.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.#ctor">
            <summary>
            Create a new empty MultiBrush with a default weight of 1.0.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.LoadCollection(OpenRA.Map,System.String)">
            <summary>Load a named MultiBrush collection from a map's tileset.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.Clone">
            <summary>
            Clone the brush. Note that this does not deep clone any ActorPlans.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.WithTemplate(OpenRA.Map,System.UInt16,OpenRA.CVec)">
            <summary>
            Add tiles from a template, optionally with a given offset. By
            default, it will be auto-offset such that the first tile is
            under (0, 0).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.WithTile(OpenRA.TerrainTile,OpenRA.CVec)">
            <summary>
            Add a single tile, optionally with a given offset. By default, it
            will be positioned under (0, 0).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.WithActor(OpenRA.Mods.Common.MapGenerator.ActorPlan)">
            <summary>Add an actor (using the ActorPlan's location as an offset).</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.WithBackingTile(OpenRA.TerrainTile)">
            <summary>
            <para>For all spaces occupied by the brush, add the given tile.</para>
            <para>This is useful for adding a backing tile for actors.</para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.ReplaceSegment(OpenRA.Mods.Common.MapGenerator.MultiBrushSegment)">
            <summary>
            Adds a Segment to this MultiBrush for later use with TilingPath.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.WithWeight(System.Int32)">
            <summary>Update the weight.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.MergeFrom(OpenRA.Mods.Common.MapGenerator.MultiBrush,OpenRA.CVec,OpenRA.MapGridType)">
            <summary>
            Add the tiles and actors from another MultiBrush into this one at a given offset.
            (Does not copy segments.)
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.Paint(OpenRA.Map,System.Collections.Generic.List{OpenRA.Mods.Common.MapGenerator.ActorPlan},OpenRA.CPos,OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability,OpenRA.Support.MersenneTwister)">
            <summary>
            <para>Paint tiles onto the map and/or add actors to actorPlans at the given location.</para>
            <para>contract specifies whether tiles or actors are allowed to be painted.</para>
            <para>An optional MersenneTwister can be provided to vary randomizable elements.</para>
            <para>If nothing could be painted, throws ArgumentException.</para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.PaintArea(OpenRA.Map,System.Collections.Generic.List{OpenRA.Mods.Common.MapGenerator.ActorPlan},OpenRA.CellLayer{OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},OpenRA.Support.MersenneTwister,System.Boolean)">
            <summary>
            Paint an area defined by replace onto map and actorPlans using availableBrushes.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.ToEditorBlitSource(OpenRA.Graphics.WorldRenderer,OpenRA.Support.MersenneTwister,OpenRA.PlayerReference)">
            <summary>
            Create a sparse EditorBlitSource from this MultiBrush. The EditorBlitSource will have
            the minimum bounding CellRegion fully containing all content. An optional
            MersenneTwister can be provided to vary randomizable elements. For actors without a
            preconfigured owner, a default owner can be specified or derived automatically.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.MultiBrush.PossibleTiles">
            <summary>All possible tiles that may be painted by this MultiBrush.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.WhiteAmplitude(System.Int32)">
            <summary>Amplitude is the same for all wavelengths.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.PinkAmplitude(System.Int32)">
            <summary>Amplitude proportional to wavelength.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.ClumpinessAmplitude(System.Int32,System.Int32)">
            <summary>
            <code>amplitude = wavelength ** (1 / (2 ** clumpiness))</code>
            Setting clumpiness to 0 is equivalent to pink noise.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.FractalNoise(OpenRA.Support.MersenneTwister,OpenRA.int2,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            <para>
            Create noise by combining multiple layers of Perlin noise of halving wavelengths.
            </para>
            <para>
            featureSize defines the largest wavelength in 1024ths of a matrix cell.
            the output.
            </para>
            <para>
            ampFunc specifies the amplitude of each wavelength. PinkAmplitude is often a suitable
            choice.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.PerlinNoise(OpenRA.Support.MersenneTwister,System.Int32)">
            <summary>
            2D Perlin Noise generator without interpolation, producing a span-by-span sized matrix.
            Output values range from -5792 to +5792.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.SymmetricFractalNoise(OpenRA.Support.MersenneTwister,OpenRA.int2,System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            <para>
            Produce symmetric 2D noise by repeatedly applying some generated Perlin noise under
            rotation and mirroring.
            </para>
            <para>
            Note that the combination of multiple noise values with varying correlations creates a
            noise with different properties to simple Perlin noise.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.NoiseUtils.SymmetricFractalNoiseIntoCellLayer(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Int32},System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            Use SymmetricFractalNoise to fill a CellLayer. The noise is aligned to the CPos
            coordinate system.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror">
            <summary>Trivial mirroring configurations defined in world space.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror.None">
            <summary>No mirror.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror.LeftMatchesRight">
            <summary>Match low X with high X in WPos space.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror.TopLeftMatchesBottomRight">
            <summary>Match low X, low Y with high X, high Y in WPos space.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror.TopMatchesBottom">
            <summary>Match low Y with high Y in WPos space.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror.TopRightMatchesBottomLeft">
            <summary>Match low X, high Y with high X, low Y in WPos space.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.MirrorPointAround(OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror,OpenRA.int2,OpenRA.int2)">
            <summary>
            <para>
            Mirrors a (zero-area) point around a given center.
            </para>
            <para>
            For example, if using a center of (40, 40) a point at (1, 1) could be projected
            to (1, 1), (1, 79), (79, 1), or (79, 79).
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.RotateAndMirrorProjectionCount(System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror)">
            <summary>
            Given rotation and mirror parameters, return the total number of projected points this
            would result in (including the original point).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.ProjectionProximity(OpenRA.int2[])">
            <summary>
            Determine the shortest distance between projected positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.ProjectionProximity(OpenRA.CPos[])">
            <summary>
            Determine the shortest distance between projected positions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.RotateAndMirrorPointAround(OpenRA.int2,OpenRA.int2,System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror)">
            <summary>
            <para>
            Duplicate an original point into an array of projected points according to a rotation
            and mirror specification.
            </para>
            <para>
            Rotations use WAngel-based trigonometric math for consistency with other Symmetry
            functions. This may be slightly imprecise for non-trivial rotations.
            </para>
            <para>
            For example, if using a center of (40, 40) a point at (1, 1) could be projected
            to (1, 1), (1, 79), (79, 1), and (79, 79).
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.RotateAndMirrorActorPlans(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.ActorPlan},System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror)">
            <summary>
            Rotate and mirror multiple actor plans. See RotateAndMirrorActorPlan.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.RotateAndMirrorActorPlan(OpenRA.Mods.Common.MapGenerator.ActorPlan,System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror)">
            <summary>
            Rotate and mirror a single actor plan, adding to an accumulator list.
            Locations (CPos) are necessarily snapped to grid.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Symmetry.RotateAndMirrorOverCPos``1(OpenRA.CellLayer{``0},System.Int32,OpenRA.Mods.Common.MapGenerator.Symmetry.Mirror,System.Action{OpenRA.CPos[],OpenRA.CPos})">
            <summary>
            Calls action(projections, original) over all possible original
            CPos positions, where each projection in projections is a
            mirrored/rotated point. For non-trivial symmetries, projections may
            be outside the bounds defined by cellLayer.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Terraformer">
            <summary>Collection of high-level map generation utilities.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.FractionMax">
            <summary>Common denominator for fractional arguments.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias">
            <summary>Biases or excludes resources at a location during resource planning.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.WPos">
            <summary>The location of the bias.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.ExclusionRadius">
            <summary>Resources will not be placed within this distance of the actor.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.BiasRadius">
            <summary>Resources will be biased within this radius.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.Bias">
            <summary>
            Biasing function, applied either to all resources or the specific ResourceType.
            Maps the original value and the squared-WDist-from-CPos to a new value.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.ResourceType">
            <summary>If non-null, encourages resources to become this type.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.#ctor(OpenRA.WPos)">
            <summary>Create a bias at a location.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias.#ctor(OpenRA.Mods.Common.MapGenerator.ActorPlan)">
            <summary>Create a bias at an actor's location.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.Terraformer.Region">
            <summary>
            Metadata for the values in a CellLayer matching an ID.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.Region.Id">
            <summary>Region ID.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.Terraformer.Region.Area">
            <summary>Area of the region.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ActorsOfType(System.String)">
            <summary>
            Enumerates through all current ActorPlans of the given type.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.InitMap">
            <summary>Perform some basic initialization of a map.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.BakeMap">
            <summary>
            Commits draft data to the map, such as player and actor definitions.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ImproveSymmetry``1(OpenRA.CellLayer{``0},``0,System.Func{``0,``0,``0})">
            <summary>
            Return a new CellLayer produced by aggregating projected cells from an input CellLayer.
            The input does not need to have the same shape as the map.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.DezoneActor(OpenRA.Mods.Common.MapGenerator.ActorPlan,OpenRA.CellLayer{System.Boolean},System.Nullable{OpenRA.WDist})">
            <summary>
            Subtract an actor's footprint from zoneable. Optionally, a circle with a given dezone
            radius from the actor center can also be subtracted from zoneable.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ZoneFromActors``1(OpenRA.CellLayer{``0},``0)">
            <summary>Sets all zoneable cells where the map has actor footprints to false.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ZoneFromResources``1(OpenRA.CellLayer{``0},``0)">
            <summary>Sets all zoneable cells where the map has resources to false.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.CheckSpace(System.Collections.Generic.IReadOnlySet{System.Byte},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a CellLayer describing whether the space in a map satisfies given terrain types
            (if allowedTerrain is non-null), is free of actors, and/or is free of resources.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.CheckSpace(System.UInt16,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a CellLayer describing whether the space in a map has the given tile type and
            is free of actors and/or resources.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ErodeZones(OpenRA.CellLayer{System.Boolean},System.Int32)">
            <summary>
            Shrink zoneable areas by a given thickness in cells. Zones will be shrunk even if they
            border the edge of the map.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.GetZoneable(System.Collections.Generic.IReadOnlySet{System.Byte},OpenRA.CellLayer{System.Boolean})">
            <summary>
            Derives a CellLayer identifying the space in a map available for various actors,
            resources, decorations, etc. A mask (usually playable space) can be used to further
            limit the zoneable area.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.CenteredCircle``1(``0,``0,OpenRA.WDist)">
            <summary>Create map-shaped CellLayer preinitialized with a circle.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ProjectionSpacing">
            <summary>
            Return a CellLayer where each cell is half the minimum distances to one of its symmetry
            projections. Can be used to avoid placing actors too close to their own projections.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.FindAsymmetries(System.Collections.Generic.IReadOnlySet{System.Byte},System.Boolean,System.Boolean)">
            <summary>
            Produce a cell layer which identifies assymetries in the map.
            Cells that are considered recessive but that have dominant projections are marked as
            true in the resulting CellLayer.
            </summary>
            <param name="dominantTerrain">Cells matching these terrain types are consided dominant.</param>
            <param name="dominantActors">If true, cells covered by actors are considered dominant.</param>
            <param name="strictTerrainTypes">
            Also mark as true any cells where the terrain types don't match with projections, even
            if they are also all recessive.
            </param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.FindRegions(OpenRA.CellLayer{System.Boolean},System.Collections.Immutable.ImmutableArray{OpenRA.CVec})">
            <summary>
            Given a space CellLayer, identifies the separate true regions. Cells are part of the
            same region if they are connected by an offset in spread.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ChoosePlayableRegion(OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Boolean})">
            <summary>
            Finds the largest, symmetrical, unpoisoned playable region on the map.
            Returns a CellLayer describing the playable region, or null if there is no suitable
            playable region.
            </summary>
            <param name="playable">Whether given cells are playable.</param>
            <param name="poison">Any regions with a poisoned cell are disqualified. Can be null.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.SpawnBias(System.Int32)">
            <summary>
            Generate a CellLayer containing scores for the preferability of spawn locations, based
            on separation from symmetry projections and the map center. Higher scores are better.
            </summary>
            <param name="centralReservationFraction">
            Distance from the map center or symmetry lines inside of which spawns are biased away
            from. Measured as a fraction (out of 1024) of the map's smallest dimension.
            </param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ChooseSpawnInZoneable(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Finds a random suitable mpspawn location, biased away from symmetries and the map
            center. Returns null if nowhere is suitable.
            </summary>
            <param name="random">Random source for spawn placement.</param>
            <param name="zoneable">Mask of valid space for spawn (and other object) placement.</param>
            <param name="centralReservationFraction">
            Distance from the map center or symmetry lines inside of which spawns are biased away
            from. Measured as a fraction (out of 1024) of the map's smallest dimension.
            </param>
            <param name="minimumRadius">Minimum space required for a spawn.</param>
            <param name="maximumRadius">Maximum space used by a spawn, beyond which larger spaces are equally preferable.</param>
            <param name="zoneRadius">
            Space that spawns are expected to reserve in zoneable. Note that this function does not
            modify zoneable, but this is needed in order to avoid placing symmetry-projected spawns
            with overlapping zone allocations.
            </param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ChooseInZoneable(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.Int32)">
            <summary>
            Find a random cell in zoneable with the most free space. Spaces which are maximumSpace
            or more away from unzoned cells are treated equally.
            Returns the CPos and space (up to maximumSpace) of the chosen cell.
            The space value will be negative if there are no zoned cells.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.TargetWalkingDistance(OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Boolean},System.Collections.Generic.IEnumerable{OpenRA.CPos},OpenRA.WDist,OpenRA.WDist)">
            <summary>
            Generate a CellLayer scoring cells on how close to a target walking distance through
            walkable cells they are from the closest seed point. Higher scores are better. The
            score considers the distance needed to walk around unwalkable cells. Unsuitable cells
            will have a score of -int.MaxValue.
            </summary>
            <param name="walkable">Walkable cells.</param>
            <param name="mask">Unmasked cells will have a score of -int.MaxValue. Can be null.</param>
            <param name="seeds">Points from which to measure walking distance.</param>
            <param name="targetRange">The highest scoring walking distance..</param>
            <param name="maximumRange">Distances greater than this are given a score of -int.MaxValue.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ProjectPlaceDezoneActor(OpenRA.Mods.Common.MapGenerator.ActorPlan,OpenRA.CellLayer{System.Boolean},System.Nullable{OpenRA.WDist})">
            <summary>
            Add an actor and its symmetry projections to the map and subtract its footprint from
            zoneable. Optionally, a circle with a given dezone radius from the actor center can
            also be subtracted from zoneable.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.AddActor(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.String,System.Nullable{OpenRA.WDist})">
            <summary>
            Chooses a location for an actor within zoneable, and then projects, places, and dezones
            for it. (The zoneable CellLayer is modified.)
            </summary>
            <returns>True if an actor was placed, false if there was insufficient space.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.AddDistributedActors(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Int32},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.Int32,System.Boolean,System.Nullable{OpenRA.WDist})">
            <summary>
            Given a CellLayer of weights/priorities, chooses locations for actors within zoneable,
            and then projects, places, and dezones for them.
            </summary>
            <param name="random">Random source for locations and actor type selection.</param>
            <param name="zoneable">Available space for actors. Modified if actors placed.</param>
            <param name="distribution">Weights or priorities for placing an actor centered on cells.</param>
            <param name="weightedActorTypes">Actor types to choose from and their relative weights.</param>
            <param name="targetCount">Number of actors to attempt to place.</param>
            <param name="weighted">If true, choose actor locations using probabilistic weights instead of best candidate.</param>
            <param name="actorDezoneRadius">
            Dezone radius for placed actors (in addition to footprint).
            This does not affect spacing within the region.
            </param>
            <returns>Number of actors added. 0 indicates none could be added.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.AddActorCluster(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.Collections.Generic.IReadOnlyDictionary{System.String,System.Int32},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Nullable{OpenRA.WDist},System.Func{System.Int64,System.Int32})">
            <summary>
            Chooses a location for a cluster of actors within zoneable, and then projects, places,
            and dezones for them.
            </summary>
            <param name="random">Random source for locations and actor type selection.</param>
            <param name="zoneable">Available space for actors. Modified if actors placed.</param>
            <param name="weightedActorTypes">Actor types to choose from and their relative weights.</param>
            <param name="targetCount">Number of actors to attempt to place.</param>
            <param name="innerReservation">Avoid placing actors' centers within this radius unless it's a last resort.</param>
            <param name="minimumRadius">Minimum cluster radius for actor center placement.</param>
            <param name="maximumRadius">Maximum cluster radius for actor center placement.</param>
            <param name="outerBorder">Zoneable spacing required beyond radius (that actors' centers will not be placed in).</param>
            <param name="weighted">If true, choose actor locations using probabilistic weights instead of best candidate.</param>
            <param name="actorDezoneRadius">
            Dezone radius for placed actors (in addition to footprint).
            This does not affect spacing within the cluster.
            </param>
            <param name="distributor">
            Calculates location weights or candidate priorities based on distance from the cluster
            center. The input is the WDist.LengthSquared from the cluster center. Location choices
            are biased towards greater outputs. If null, defaults to a function where the weight is
            proportional to the squared distance, thus biasing actors towards the outside.
            </param>
            <returns>Number of actors added. 0 indicates none could be added.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PickTile(OpenRA.Support.MersenneTwister,System.UInt16)">
            <summary>
            For a 1x1 tile, return a TerrainTile with the given tile type, using a random index if
            it's a PickAny template.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PaintArea(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Boolean)">
            <summary>Wrapper around MultiBrush.PaintArea.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PaintActors(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Boolean)">
            <summary>
            Wrapper around PaintArea that uses Replacibility.Actor for masked cells.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PaintTiling(OpenRA.Support.MersenneTwister,OpenRA.Mods.Common.MapGenerator.MultiBrush)">
            <summary>Wrapper around MultiBrush.Paint for path tiling results.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.RepaintTiles(OpenRA.Support.MersenneTwister,System.Collections.Generic.IReadOnlyDictionary{System.UInt16,System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush}})">
            <summary>
            Repaint the areas occupied by given tile types using MultiBrushes.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.BooleanNoise(OpenRA.Support.MersenneTwister,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a boolean fractal noise pattern obeying symmetry requirements.
            <param name="random">Random source</param>
            <param name="noiseFeatureSize">Largest interval for fractal noise.</param>
            <param name="fraction">Target fraction of true values (from 0 to FractionMax).</param>
            <param name="clumpiness">
            The number of times to square root the noise wavelength to arrive at the amplitude.
            In other words, amplitude = wavelength ** (1 / (2 ** clumpiness))
            Setting to 0 is equivalent to pink noise.
            </param>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ElevationNoiseMatrix(OpenRA.Support.MersenneTwister,System.Int32,System.Int32)">
            <summary>
            Create a matrix containing a generated terrain elevation map.
            </summary>
            <param name="random">Random source for terrain noise.</param>
            <param name="noiseFeatureSize">Largest interval for fractal noise.</param>
            <param name="smoothing">Range in cells for smoothing.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceNoise(OpenRA.Support.MersenneTwister,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Produce an unbiased noise pattern for resource growth.
            </para><para>
            The output noise will have the range [uniformity, uniformity + 1024].
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.SliceElevation(OpenRA.Mods.Common.MapGenerator.Matrix{System.Int32},OpenRA.Mods.Common.MapGenerator.Matrix{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Given elevation noise, partition it into a boolean Matrix where false represents low
            elevation and true represents high elevation.
            </summary>
            <param name="elevation">Terrain elevation noise.</param>
            <param name="mask">
            A mask (usually a previous slice) within which the new slice is constrained to and
            derived from. Can be null to imply all space is available.
            </param>
            <param name="fraction">Target fraction (out of FractionMax) of masked terrain to be carried over to the new slice.</param>
            <param name="minimumContourSpacing">Minimum distance between the contours of the mask and the new slice.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.NormalizeLoopStart(OpenRA.int2[])">
            <summary>
            If given a looped path, normalizes it such that symmetry projected paths should have
            symmetry projected start/end points. Note that this method isn't meaningful for loops
            which would overlap with their symmetry projections. For non-looped paths, returns the
            input unchanged.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PartitionPath(OpenRA.int2[],System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.Terraformer.PathPartitionZone},OpenRA.Mods.Common.MapGenerator.Matrix{OpenRA.Mods.Common.MapGenerator.Terraformer.PathPartitionZone},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Int32)">
            <summary>
            Given a matrix-style path, divide it into a chain of smaller paths and convert them to
            TilingPaths with segment types that best match a matrix of zones.
            </summary>
            <param name="path">The path to be divided.</param>
            <param name="allZones">The full set of zones, in order of preference for ties.</param>
            <param name="zoneMask">
            Matrix which assigns zones to matching points in the path.
            Null values can be used to describe locations with no zoning preference.
            </param>
            <param name="brushes">Segmented brushes for TilingPath creation.</param>
            <param name="minimumStraight">
            If greater than zero, sub-paths are only allowed to change over in straight sections
            and the starts/ends must be this number of points deep within a straight section.
            </param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PartitionPaths(System.Collections.Generic.IEnumerable{OpenRA.int2[]},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.Terraformer.PathPartitionZone},OpenRA.Mods.Common.MapGenerator.Matrix{OpenRA.Mods.Common.MapGenerator.Terraformer.PathPartitionZone},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Int32)">
            <summary>Wrapper around PartitionPath to process multiple paths at once.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PaintLoopsAndFill(OpenRA.Support.MersenneTwister,System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.TilingPath},OpenRA.Mods.Common.MapGenerator.Terraformer.Side,System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},OpenRA.CellLayer{OpenRA.Mods.Common.MapGenerator.MultiBrush.Replaceability})">
            <summary>
            Wrapper around InsideOutside which performs both path tiling and side filling, painting
            the result to the map. If tiling fails, returns null without modifying the map.
            </summary>
            <param name="random">Random source used for tiling and filling.</param>
            <param name="tilingPaths">
            Paths to tile. Note that these are tiled exactly as specified, so if end deviation is
            enabled, this will allow tiling errors.
            </param>
            <param name="fallback">Side to assume if no paths are contained in the map.</param>
            <param name="outside">If non-null, these MultiBrushes are painted over outside regions.</param>
            <param name="inside">If non-null, these MultiBrushes are painted over inside regions.</param>
            <param name="replaceMask">Optional replaceability constraints for filling. Ignored for path tiling.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.InsideOutside(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},OpenRA.Mods.Common.MapGenerator.Terraformer.Side)">
            <summary>
            Given a collection of path tiling results which form non-nested loops or extend beyond
            or out to the map edge, return a CellLayer identifying whether cells are inside or
            outside of the tiled loops, or Side.None if the cell is covered by a MultiBrush.
            If a loop wraps around a space clockwise, that space is considered inside.
            </summary>
            <param name="tilings">Path tiling results which partition the space.</param>
            <param name="fallback">Side to assume if no paths are contained in the map.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.FillUnmaskedSideAndBorder(OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{OpenRA.Mods.Common.MapGenerator.Terraformer.Side},OpenRA.Mods.Common.MapGenerator.Terraformer.Side,System.Action{OpenRA.CPos})">
            <summary>
            Fill a CellLayer with a given value to identify or undo the effects of painting sided
            regions. For example, this can be used to un-paint an unplayable body of water along
            with its beaches.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PlanPassages(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Plan passageway cutouts that, when subtracted away from obstructions, preserve
            connectivity through a given space.
            </summary>
            <param name="random">Random source for carving addition passageways to comply with maximumCutoutSpacing.</param>
            <param name="space">Describes the space through which connectivity needs to be preserved.</param>
            <param name="cutoutRadius">Half-thickness of passageways.</param>
            <param name="maximumCutoutSpacing">
            If greater than zero, inserts additional passageways, ensuring that passageways are no
            greater than this distance apart (in Chebyshev distance).
            </param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PlanRoads(OpenRA.CellLayer{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Plan paths for roads that travel through the middle of playable space.
            </summary>
            <param name="availableSpace">Space in which roads are permitted.</param>
            <param name="minimumSpacing">Minimum distance that roads must be from the edges of available space.</param>
            <param name="minimumLength">Roads shorter than this will be merged or pruned.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.PlanResources(OpenRA.CellLayer{System.Int32},OpenRA.CellLayer{System.Boolean},OpenRA.Mods.Common.Traits.ResourceLayerInfo.ResourceTypeInfo,System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.Terraformer.ResourceBias})">
            <summary>
            Given a resource noise pattern, rank cells for resource growth. (Higher is better.)
            Resources will be limited to masked cells. Resources will only be placed on compatible
            terrain tiles and will avoid actor footprints.
            Resources can be biased towards or away from specified actors. Biases are applied in
            the order they are supplied, but all reservations take precedence.
            Resource type will be determined by proximity to resource spawn actors, or a default
            resource.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.GrowResources(OpenRA.CellLayer{System.Int32},OpenRA.CellLayer{OpenRA.Mods.Common.Traits.ResourceLayerInfo.ResourceTypeInfo},System.Int64)">
            <summary>
            Given a resource plan, place resources onto the map up to a target value.
            Resources are placed first on the pattern cells with the greatest value.
            No resources will be placed on pattern cells with a value less than 0.
            The plan should only contain values >= 0 where resource placement is legal.
            The type of resource placed is specified by typePlan.
            Any previously existing resources on the map will be cleared.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.Terraformer.DecorationPattern(OpenRA.Support.MersenneTwister,OpenRA.CellLayer{System.Boolean},OpenRA.CellLayer{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a mask for placing decorations in out-of-the-way locations on a map.
            </summary>
            <param name="random">Random source for layout and tiling.</param>
            <param name="space">Space that decorations must not significantly choke.</param>
            <param name="zoneable">Cells where decoration is allowed.</param>
            <param name="coverage">Maximum fraction of map to cover in decorations.</param>
            <param name="featureSize">Noise feature size for layout.</param>
            <param name="density">Density of decoration layout.</param>
            <param name="minimumDensity">
            Enforces a minimum local density of decorations. This can, for example, be used to
            ensure that villages have a substantial size, preventing lonely buildings. Decoration
            cells are removed until the minimum density is satisfied for remaining cells.
            </param>
            <param name="minimumDensityRadius">Enforcement radius of minimum density.</param>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.TilingPath">
            <summary>Path to be tiled onto a map using MultiBrushSegments.</summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.TilingPath.Terminal">
            <summary>Describes the type and direction of the start or end of a TilingPath.</summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.Terminal.Direction">
            <summary>
            Direction to use for this terminal.
            If the direction here is null, it will be determined automatically later.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.TilingPath.Terminal.SegmentType">
            <summary>
            A string which can match the format used by MultiBrushSegment's Start or End.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments">
            <summary>
            Describes the permitted start, middle, and end segments/MultiBrushes that can be used
            to tile a path.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments.FromType(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a PermittedSegments using only the given types.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments.FromInnerAndTerminalTypes(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a PermittedSegments suitable for a path with given inner and terminal types
            at the start and end.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments.FromTypes(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a PermittedSegments suitable for a path with given inner and terminal types
            at the start and end.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments.FindSegments(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Equivalent to FindSegments(multiBrushes, types, types, types).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.PermittedSegments.FindSegments(System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filter MultiBrushes to segments that use the given start, inner, and end types.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.Points">
            <summary>
            <para>
            Target point sequence to fit MultiBrushSegments to. Whether these CPos positions
            represent cell corners or cell centers is dependent on the system used by the path's
            PermittedSegments' MultiBrushSegments.
            </para>
            <para>
            If null, Tiling will be a no-op. If non-null, must have at least two points.
            </para>
            <para>
            A loop must have the start and end points equal.
            </para>
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.MaxDeviation">
            <summary>
            Maximum permitted Chebyshev distance that layed MultiBrushSegments may be from the
            specified points.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.MaxSkip">
            <summary>
            Determines how much corner-cutting is allowed.
            A value of zero will result in a value being derived from MaxDeviation.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.MinSeparation">
            <summary>
            Increases separation between permitted tiling regions of different parts of the path.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.MaxEndDeviation">
            <summary>
            If the path cannot be tiled exactly, the resulting tiling is allowed to deviate from
            target end point by this Chebychev distance. Ignored for loops. This will be capped to
            MaxDeviation at tiling time.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.Start">
            <summary>
            Stores start type and direction.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.MapGenerator.TilingPath.End">
            <summary>
            Stores end type and direction.
            </summary>
        </member>
        <member name="P:OpenRA.Mods.Common.MapGenerator.TilingPath.IsLoop">
            <summary>Whether the start and end points are the same.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.QuickCreate(OpenRA.Map,System.Collections.Generic.IReadOnlyList{OpenRA.Mods.Common.MapGenerator.MultiBrush},OpenRA.CPos[],System.Int32,System.String,System.String)">
            <summary>
            Convenience method to create TilingPaths using common settings.
            Start and end terminal types are the same.
            PermittedSegments are derived from brushes and inner/terminal types.
            Loops will automatically use only the inner type.
            Uses automatic end deviation and loop optimization.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.Tile(OpenRA.Support.MersenneTwister)">
            <summary>
            <para>
            Attempt to tile the given path, producing a new MultiBrush if the path could be tiled,
            or null if the path could not be tiled within constraints.
            </para>
            <para>
            The resulting MultiBrush is created from stitching MultiBrushes from the
            PermittedSegments together, and will contain a segment that represents the stitched
            segments of the constituent MultiBrushes.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.InertiallyExtend(System.Int32,System.Int32)">
            <summary>
            <para>
            Extend the start and end of a path by extensionLength points. The directions of the
            extensions are based on the overall direction of the outermost inertialRange points.
            </para>
            <para>
            Returns the object being called on.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.InertiallyExtendPathPoints(OpenRA.CPos[],System.Int32,System.Int32)">
            <summary>
            Extend the start and end of a path by extensionLength points. The directions of the
            extensions are based on the overall direction of the outermost inertialRange points.
            Loops are left unmodified.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.ExtendEdge(System.Int32)">
            <summary>
            <para>
            For map edge-connected (non-loop) starts/ends, the path is extended beyond the edge.
            For loops or paths which don't connect to the map edge, no change is applied.
            </para>
            <para>
            For the purposes of this function, the map edges are defined as the borders of a
            minimal CPos-aligned rectangle covering the entire map. These are not the true edges of
            a RectangularIsometric map.
            </para>
            <para>
            Starts/ends which are corner-connected or already extend beyond the edge are unaltered.
            </para>
            <para>
            Returns the object being called on.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.ExtendEdgePathPoints(OpenRA.CPos[],OpenRA.Primitives.Rectangle,System.Int32)">
            <summary>
            <para>
            For bounds edge-connected (non-loop) starts/ends, the path is extended beyond the edge.
            For loops or paths which don't connect to the edges, the input points are returned
            unaltered.
            </para>
            <para>
            Starts/ends which are corner-connected or already extend beyond the edge are unaltered.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.OptimizeLoop">
            <summary>
            <para>
            For loops, points are rotated such that the start/end reside in the longest straight.
            For non-loops, the input points are returned unaltered.
            </para>
            <para>
            Returns the object being called on.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.OptimizeLoopPathPoints(OpenRA.CPos[])">
            <summary>
            For loops, points are rotated such that the start/end reside in the longest straight.
            For non-loops, the input points are returned unaltered.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.Shrink(System.Int32,System.Int32)">
            <summary>
            <para>
            Shrink a path by a given amount at both ends. If the number of points in the path drops
            below minimumLength, the path is nullified.
            </para>
            <para>
            If a loop is provided, the path is not shrunk, but the minimumLength requirement still
            holds.
            </para>
            <para>
            Returns the object being called on.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.ShrinkPathPoints(OpenRA.CPos[],System.Int32,System.Int32)">
            <summary>
            <para>
            Shrink a path by a given amount at both ends. If the number of points in the path drops
            below minimumLength, null is returned.
            </para>
            <para>
            If a loop is provided, the path is not shrunk, but the minimumLength requirement still
            holds.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.ChirallyNormalize(System.Func{OpenRA.CPos,OpenRA.WVec})">
            <summary>
            <para>
            Takes a path and normalizes its progression direction around the map center.
            Normalized but opposing paths rotate around the center in the same direction.
            </para>
            <para>
            The measureFromCenter function must convert CVec positions to WVec offsets from the map
            center.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.ChirallyNormalizePathPoints(OpenRA.CPos[],System.Func{OpenRA.CPos,OpenRA.WVec})">
            <summary>
            <para>
            Takes a path and normalizes its progression direction around the map center.
            Normalized but opposing paths rotate around the center in the same direction.
            </para>
            <para>
            Loops are normalized to rotate in a consistent direction, regardless of position.
            </para>
            <para>
            The measureFromCenter function must convert CVec positions to WVec offsets from the map
            center.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.RetainDisjointPaths(System.Collections.Generic.IEnumerable{OpenRA.CPos[]})">
            <summary>
            <para>
            Retains paths which have no points in common with earlier (previous and retained) paths
            from the input.
            </para>
            <para>
            The underlying point sequences are NOT cloned.
            </para>
            <para>
            All input sequences must be non-null.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.RetainIfValid">
            <summary>Nullify the path's points if they aren't suitable for tiling.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.StraightenEnds(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Applies StraightenEndsPathPoints to this TilingPath, returning this.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.StraightenEndsPathPoints(OpenRA.CPos[],OpenRA.Primitives.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Straighten the start and end of a path by shrinking and regrowing a straight section.
            </summary>
            <param name="points">Points of the path.</param>
            <param name="bounds">Map bounds, used to identify paths touching edges.</param>
            <param name="shrink">Distance to shrink path ends (before regrowing them).</param>
            <param name="grow">Distance to regrow path ends with straightening (after shrinking).</param>
            <param name="minimumLength">The minimum length (after shrinking, before growth) that paths may be.</param>
            <param name="growthInertialRange">How many points are used to decide the regrowth direction.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.SetMaxEndDeviation(System.Int32)">
            <summary>Set MaxEndDeviation.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.MapGenerator.TilingPath.SetAutoEndDeviation">
            <summary>Allow end point deviation as far as MaxDeviation will allow.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Orders.UnitOrderGenerator.OrderForUnit(OpenRA.Actor,OpenRA.Traits.Target,OpenRA.CPos,OpenRA.MouseInput)">
            <summary>
            Returns the most appropriate order for a given actor and target.
            First priority is given to orders that interact with the given actors.
            Second priority is given to actors in the given cell.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.CellStatus">
            <summary>
            Describes the three states that a node in the graph can have.
            Based on A* algorithm specification.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.CellInfo">
            <summary>
            Stores information about nodes in the pathfinding graph.
            The default value of this struct represents an <see cref="F:OpenRA.Mods.Common.Pathfinder.CellStatus.Unvisited"/> location.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.CellInfo.Status">
            <summary>
            The status of this node. Accessing other fields is only valid when the status is not <see cref="F:OpenRA.Mods.Common.Pathfinder.CellStatus.Unvisited"/>.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.CellInfo.CostSoFar">
            <summary>
            The cost to move from the start up to this node.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.CellInfo.EstimatedTotalCost">
            <summary>
            The estimation of how far this node is from our target.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.CellInfo.PreviousNode">
            <summary>
            The previous node of this one that follows the shortest path.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.DensePathGraph">
            <summary>
            A dense pathfinding graph that implements the ability to cost and get connections for cells,
            and supports <see cref="T:OpenRA.Mods.Common.Traits.ICustomMovementLayer"/>. Allows searching over a dense grid of cells.
            Derived classes are required to provide backing storage for the pathfinding information.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.DensePathGraph.IsValidNeighbor(OpenRA.CPos)">
            <summary>
            Determines if a candidate neighbouring position is
            allowable to be returned in a <see cref="T:OpenRA.Mods.Common.Pathfinder.GraphConnection"/>.
            </summary>
            <param name="neighbor">The candidate cell. This might not lie within map bounds.</param>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.Grid">
            <summary>
            Represents a simplistic grid of cells, where everything in the
            top-to-bottom and left-to-right range is within the grid.
            The grid can be restricted to a single layer, or allowed to span all layers.
            </summary>
            <remarks>
            This means in <see cref="F:OpenRA.MapGridType.RectangularIsometric"/> some cells within a grid may lay off the map.
            Contrast this with <see cref="T:OpenRA.CellRegion"/> which maintains the simplistic grid in map space -
            ensuring the cells are therefore always within the map area.
            The advantage of Grid is that it has straight edges, making logic for adjacent grids easy.
            A CellRegion has jagged edges in RectangularIsometric, which makes that more difficult.
            </remarks>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.Grid.TopLeft">
            <summary>
            Inclusive.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.Grid.BottomRight">
            <summary>
            Exclusive.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.Grid.SingleLayer">
            <summary>
            When true, the grid spans only the single layer given by the cells. When false, it spans all layers.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.Grid.Contains(OpenRA.CPos)">
            <summary>
            Checks if the cell X and Y lie within the grid bounds. The cell layer must also match.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.Grid.IntersectsLine(OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Checks if the line segment from <paramref name="start"/> to <paramref name="end"/>
            passes through the grid boundary. The cell layers are ignored.
            A line contained wholly within the grid that doesn't cross the boundary is not counted as intersecting.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.GridPathGraph">
            <summary>
            A dense pathfinding graph that supports a search over all cells within a <see cref="T:OpenRA.Mods.Common.Pathfinder.Grid"/>.
            Cells outside the grid area are deemed unreachable and will not be considered.
            It implements the ability to cost and get connections for cells, and supports <see cref="T:OpenRA.Mods.Common.Traits.ICustomMovementLayer"/>.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder">
             <summary>
             Provides pathfinding abilities for actors that use a specific <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/>.
             Maintains a hierarchy of abstract graphs that provide a more accurate heuristic function during
             A* pathfinding than the one available from <see cref="M:OpenRA.Mods.Common.Pathfinder.PathSearch.DefaultCostEstimator(OpenRA.Mods.Common.Traits.Locomotor)"/>.
             This allows for faster pathfinding.
             </summary>
             <remarks>
             <para>The goal of this pathfinder is to increase performance of path searches. <see cref="T:OpenRA.Mods.Common.Pathfinder.PathSearch"/> is used
             to perform a path search as usual, but a different heuristic function is provided that is more accurate. This
             means fewer nodes have to be explored during the search, resulting in a performance increase.</para>
            
             <para>When an A* path search is performed, the search expands outwards from the source location until the
             target is found. The heuristic controls how this expansion occurs. When the heuristic of h(n) = 0 is given, we
             get Dijkstra's algorithm. The search grows outwards from the source node in an expanding circle with no sense
             of direction. This will find the shortest path by brute force. It will explore many nodes during the search,
             including lots of nodes in the opposite direction to the target.</para>
            
             <para><see cref="M:OpenRA.Mods.Common.Pathfinder.PathSearch.DefaultCostEstimator(OpenRA.Mods.Common.Traits.Locomotor)"/> provides heuristic for searching a 2D grid. It
             estimates the cost as the straight-line distance between the source and target nodes. The search grows in a
             straight line towards the target node. This is a vast improvement over Dijkstra's algorithm as we now
             prioritize exploring nodes that lie closer to the target, rather than exploring nodes that take us away from
             the target.</para>
            
             <para>This default straight-line heuristic still has drawbacks - it is unaware of the obstacles on the grid. If
             the route to be found requires steering around obstacles then this heuristic can perform badly. Imagine a path
             that must steer around a lake, or move back on itself to get out of a dead end. In these cases the straight-line
             heuristic moves blindly towards the target, when actually the path requires that we move sidewards or even
             backwards to find a route. When this occurs then the straight-line heuristic ends up exploring nodes that
             aren't useful - they lead us into dead ends or directly into an obstacle that we need to go around instead.
             </para>
            
             <para>The <see cref="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder"/> improves the heuristic by making it aware of unreachable map
             terrain. A "low-resolution" version of the map is maintained, and used to provide an initial route. When the
             search is conducted it explores along this initial route. This allows the search to "know" it needs to go
             sideways around the lake or backwards out of the dead-end, meaning we can explore even fewer nodes.</para>
            
             <para>The "low-resolution" version of the map is referred to as the abstract graph. The abstract graph is
             created by dividing the map up into a series of grids, of say 10x10 nodes. Within each grid, we determine the
             connected regions of nodes within that grid. If all the nodes within the grid connect to each other, we have
             one such region. If they are split up by impassable terrain then we may have two or more regions within the
             grid. Every region will be represented by one node in the abstract graph (an abstract node, for short).</para>
            
             <para>When a path search is to be performed, we first perform a A* search on the abstract graph with the
             <see cref="M:OpenRA.Mods.Common.Pathfinder.PathSearch.DefaultCostEstimator(OpenRA.Mods.Common.Traits.Locomotor)"/>. This graph is much smaller than the full map, so
             this search is quick. The resulting path gives us the initial route between each abstract node. We can then use
             this to create the improved heuristic for use on the path search on the full resolution map. When determining
             the cost for the node, we can use the straight-line distance towards the next abstract node as our estimate.
             Our search is therefore guided along the initial route.</para>
            
             <para>This implementation only maintains one level of abstract graph, but a hierarchy of such graphs is
             possible. This allows the top-level and lowest resolution graph to be as small as possible - important because
             it will be searched using the dumbest heuristic. Each level underneath is higher-resolution and contains more
             nodes, but uses a heuristic informed from the previous level to guide the search in the right direction.</para>
            
             <para>This implementation is aware of movement costs over terrain given by
             <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.MovementCostToEnterCell(OpenRA.Actor,OpenRA.CPos,OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Actor,System.Boolean)"/>. It is aware of
             changes to the costs in terrain and able to update the abstract graph when this occurs. It is able to search
             the abstract graph as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> had been specified. If
             <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> is given in the constructor, the abstract graph will additionally
             account for a subset of immovable actors using the same rules as
             <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.CanMoveFreelyInto(OpenRA.Actor,OpenRA.CPos,OpenRA.Traits.SubCell,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Actor,System.Boolean)"/>. It will be aware
             of changes to actors on the map and update the abstract graph when this occurs. Other types of blocking actors
             will not be accounted for in the heuristic.</para>
            
             <para>If the obstacle on the map is from terrain (e.g. a cliff or lake) the heuristic will work well. If the
             obstacle is from the subset of immovable actors (e.g. trees, walls, buildings) and
             <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> was given, the heuristic will work well. If the obstacle is from other
             actors (e.g. units) then the heuristic is unaware of these. Therefore the same problem where the search goes in
             the wrong direction is possible, e.g. through a choke-point that has units blocking it. In this scenario the
             performance benefit will be lost, as the search will have to explore more nodes until it can get around the
             obstacle.</para>
            
             <para>In summary, the <see cref="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder"/> reduces the performance impact of path searches that
             must go around terrain, and some types of actor, but does not improve performance of searches that must go
             around the remaining types of actor.</para>
             </remarks>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.gridInfos">
            <summary>
            Index by a <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.GridIndex(OpenRA.CPos)"/>.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.abstractGraph">
            <summary>
            The abstract graph is represented here.
            An abstract node is the key, and costs to other abstract nodes are then available.
            Abstract nodes with no connections are NOT present in the graph.
            A lookup will fail, rather than return an empty list.
            </summary>
        </member>
        <member name="F:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.abstractDomains">
            <summary>
            The abstract domains are represented here.
            An abstract node is the key, and a domain index is given.
            If the domain index of two nodes is equal, a path exists between them (ignoring all blocking actors).
            If unequal, no path is possible.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.GridInfo">
            <summary>
            Knows about the abstract nodes within a grid. Can map a local cell to its abstract node.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.GridInfo.AbstractCellForLocalCell(OpenRA.CPos,OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder)">
            <summary>
            Maps a local cell to a abstract node in the graph.
            Returns null when the local cell is unreachable.
            Pass a null <paramref name="hpf"/> to skip cost checks if the caller already checked.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.AbstractGraphWithInsertedEdges">
            <summary>
            Represents an abstract graph with some extra edges inserted.
            Instead of building a new dictionary with the edges added, we build a supplemental dictionary of changes.
            This is to avoid copying the entire abstract graph.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.BuildGrids">
            <summary>
            Divides the map area up into a series of grids.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.BuildGrid(System.Int32,System.Int32,OpenRA.Mods.Common.Traits.ICustomMovementLayer[])">
            <summary>
            Determines the abstract nodes within a single grid. One abstract node will be created for each set of cells
            that are reachable from each other within the grid area. A grid with open terrain will commonly have one
            abstract node. If impassable terrain such as cliffs or water divides the cells into 2 or more distinct
            regions, one abstract node is created for each region. We also remember which cells belong to which
            abstract node. Given a local cell, this allows us to determine which abstract node it belongs to.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.BuildCostTable">
            <summary>
            Builds the abstract graph in entirety. The abstract graph contains edges between all the abstract nodes
            that represent the costs to move between them.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.GetAbstractEdgesForGrid(System.Int32,System.Int32,OpenRA.Mods.Common.Traits.ICustomMovementLayer[])">
            <summary>
            For a given grid, determines the edges between the abstract nodes within the grid and the abstract nodes
            within adjacent grids on the same layer. Also determines any edges available to grids on other layers via
            custom movement layers.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RequireCostRefreshInCell(OpenRA.CPos,System.Int16,System.Int16)">
            <summary>
            When reachability changes for a cell, marks the grid it belongs to as out of date.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RequireBlockingRefreshInCell(OpenRA.CPos)">
            <summary>
            When actors change for a cell, marks the grid it belongs to as out of date.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RequireProjectionRefreshInCell(OpenRA.CPos)">
            <summary>
            When map projection changes for a cell, marks the grid it belongs to as out of date.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorIsBlocking(OpenRA.Actor)">
            <summary>
            <para>
            <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> defines immovability based on the mobile trait. The blocking rules
            in <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.CanMoveFreelyInto(OpenRA.Actor,OpenRA.CPos,OpenRA.Traits.SubCell,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Actor,System.Boolean)"/> allow units
            to pass these immovable actors if they are temporary blockers (e.g. gates) or crushable by the locomotor.
            Since our abstract graph must work for any actor, we have to be conservative and can only consider a subset
            of the immovable actors in the graph - ones we know cannot be passed by some actors due to these rules.
            Both this and <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorCellIsBlocking(OpenRA.Actor,OpenRA.CPos)"/> must be true for a cell to be blocked.
            </para>
            <para>
            This method is dependent on the logic in
            <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.CanMoveFreelyInto(OpenRA.Actor,OpenRA.CPos,OpenRA.Traits.SubCell,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Actor,System.Boolean)"/> and
            <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.UpdateCellBlocking(OpenRA.CPos)"/>. This method must be kept in sync with changes in the locomotor
            rules.
            </para>
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorCellIsBlocking(OpenRA.Actor,OpenRA.CPos)">
            <summary>
            The blocking rules additionally allow some cells to be considered passable even if the actor is blocking.
            A cell is passable if the locomotor can share the cell and a subcell is available. It is also passable if
            it is a transit only cell of a <see cref="T:OpenRA.Mods.Common.Traits.Building"/>. We cannot consider these cells to be blocked.
            Both this and <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.ActorIsBlocking(OpenRA.Actor)"/> must be true for a cell to be blocked.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.FindPath(OpenRA.Actor,System.Collections.Generic.IReadOnlyCollection{OpenRA.CPos},OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Int32,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean,System.Boolean,OpenRA.Mods.Common.Traits.PathFinderOverlay)">
            <summary>
            Calculates a path for the actor from multiple possible sources to target, using a unidirectional search.
            Returned path is *reversed* and given target to source.
            The actor must use the same <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/> as this <see cref="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.FindPath(OpenRA.Actor,OpenRA.CPos,OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,System.Int32,System.Func{OpenRA.CPos,System.Int32},OpenRA.Actor,System.Boolean,System.Boolean,OpenRA.Mods.Common.Traits.PathFinderOverlay)">
            <summary>
            Calculates a path for the actor from source to target, using a bidirectional search.
            Returned path is *reversed* and given target to source.
            The actor must use the same <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/> as this <see cref="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.PathExists(OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines if a path exists between source and target.
            When <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given, only terrain is taken into account,
            i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was used when finding a path.
            When <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.Immovable"/> was given, a subset of immovable actors are also taken into
            account. If the method returns false, there is definitely no path. If it returns true there could be a
            path, but it is possible that there is no path because of an immovable actor that does not belong to the
            subset of actors that can be accounted for. So be careful.
            This would apply for any actor using the same <see cref="T:OpenRA.Mods.Common.Traits.Locomotor"/> as this <see cref="T:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RebuildDirtyGrids">
            <summary>
            The abstract graph can become out of date when reachability costs for terrain change.
            When this occurs, we must rebuild any affected parts of the abstract graph so it remains correct.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RebuildCostTable(System.Int32,System.Int32,OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.GridInfo,OpenRA.Mods.Common.Traits.ICustomMovementLayer[])">
            <summary>
            Updates the abstract graph to account for changes in a specific grid. Any nodes and edges related to that
            grid will be removed, new nodes and edges will be determined and then inserted into the graph.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.RebuildDomains">
            <summary>
            The abstract domains can become out of date when the abstract graph changes.
            When this occurs, we must rebuild the domain cache.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.AbstractCellForLocalCell(OpenRA.CPos)">
            <summary>
            Maps a local cell to a abstract node in the graph. Returns null when the local cell is unreachable.
            The cell must have been checked to be on the map with <see cref="M:OpenRA.Map.Contains(OpenRA.CPos)"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.AbstractCellForLocalCellNoAccessibleCheck(OpenRA.CPos)">
            <summary>
            Maps a local cell to a abstract node in the graph. Returns null when the local cell is unreachable.
            Skips the <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.CellIsAccessible(OpenRA.CPos)"/> check, if it has already been performed.
            If an accessible check has not been performed, call <see cref="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.AbstractCellForLocalCell(OpenRA.CPos)"/> instead.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.EdgeFromLocalToAbstract(OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Creates a <see cref="T:OpenRA.Mods.Common.Pathfinder.GraphEdge"/> from the <paramref name="localCell"/> to the <paramref name="abstractCell"/>.
            Return null when no edge is required, because the cells match.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.Heuristic(OpenRA.Mods.Common.Pathfinder.PathSearch,System.Int32,System.Collections.Generic.HashSet{OpenRA.CPos},System.Collections.Generic.List{OpenRA.CPos})">
            <summary>
            Uses the provided abstract search to provide an estimate of the distance remaining to the target
            (the heuristic) for a local path search. The abstract search must run in the opposite direction to the
            local search. So when searching from source to target, the abstract search must be from target to source.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.HierarchicalPathFinder.AbstractNodeForCost(OpenRA.Mods.Common.Pathfinder.SparsePathGraph,OpenRA.CPos,OpenRA.CPos)">
            <summary>
            Determines an abstract node further along the path which can be reached directly without deviating from the
            abstract path from the abstract cell of the source location.
            As this node can be reached directly we can target it instead
            of the original node to provide a better cost estimate.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.IPathGraph">
            <summary>
            Represents a pathfinding graph with nodes and edges.
            Nodes are represented as cells, and pathfinding information
            in the form of <see cref="T:OpenRA.Mods.Common.Pathfinder.CellInfo"/> is attached to each one.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.IPathGraph.GetConnections(OpenRA.CPos,System.Func{OpenRA.CPos,System.Boolean})">
            <summary>
            Given a source node, returns connections to all reachable destination nodes with their cost.
            </summary>
            <remarks>PERF: Returns a <see cref="T:System.Collections.Generic.List`1"/> rather than an <see cref="T:System.Collections.Generic.IEnumerable`1"/> as enumerating
            this efficiently is important for pathfinding performance. Callers should interact with this as an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> and not mutate the result.</remarks>
        </member>
        <member name="P:OpenRA.Mods.Common.Pathfinder.IPathGraph.Item(OpenRA.CPos)">
            <summary>
            Gets or sets the pathfinding information for a given node.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.GraphEdge">
            <summary>
            Represents a full edge in a graph, giving the cost to traverse between two nodes.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.GraphConnection">
            <summary>
            Represents part of an edge in a graph, giving the cost to traverse to a node.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.MapPathGraph">
            <summary>
            A dense pathfinding graph that supports a search over all cells within a map.
            It implements the ability to cost and get connections for cells, and supports <see cref="T:OpenRA.Mods.Common.Traits.ICustomMovementLayer"/>.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.CellAllowsMovement(OpenRA.World,OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos,System.Func{OpenRA.CPos,System.Int32})">
            <summary>
            Determines if a cell is a valid pathfinding location.
            <list type="bullet">
            <item>It is in the world.</item>
            <item>It is either on the ground layer (0) or on an *enabled* custom movement layer.</item>
            <item>It has not been excluded by the <paramref name="customCost"/>.</item>
            </list>
            If required, follow this with a call to
            <see cref="M:OpenRA.Mods.Common.Traits.Locomotor.MovementCostToEnterCell(OpenRA.Actor,OpenRA.CPos,OpenRA.CPos,OpenRA.Mods.Common.Traits.BlockedByActor,OpenRA.Actor,System.Boolean)"/> to
            determine if the cell is accessible.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.DefaultCostEstimator(OpenRA.Mods.Common.Traits.Locomotor,OpenRA.CPos)">
            <summary>
            Default: Diagonal distance heuristic. More information:
            https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
            Layers are ignored and incur no additional cost.
            </summary>
            <param name="locomotor">Locomotor used to provide terrain costs.</param>
            <param name="destination">The cell for which costs are to be given by the estimation function.</param>
            <returns>A delegate that calculates the cost estimation between the <paramref name="destination"/> and the given cell.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.DefaultCostEstimator(OpenRA.Mods.Common.Traits.Locomotor)">
            <summary>
            Default: Diagonal distance heuristic. More information:
            https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
            Layers are ignored and incur no additional cost.
            </summary>
            <param name="locomotor">Locomotor used to provide terrain costs.</param>
            <returns>A delegate that calculates the cost estimation between the given cells.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.#ctor(OpenRA.Mods.Common.Pathfinder.IPathGraph,System.Func{OpenRA.CPos,System.Boolean,System.Int32},System.Int32,System.Func{OpenRA.CPos,System.Boolean},OpenRA.Mods.Common.Pathfinder.PathSearch.IRecorder)">
            <summary>
            Initialize a new search.
            </summary>
            <param name="graph">Graph over which the search is conducted.</param>
            <param name="heuristic">Provides an estimation of the distance between the given cell and the target.
            The Boolean parameter indicates if the cell is known to be accessible.
            When true, it is known accessible as it is being explored by the search.
            When false, the cell is being considered as a starting location and might not be accessible.</param>
            <param name="heuristicWeightPercentage">
            The search will aim for the shortest path when given a weight of 100%.
            We can allow the search to find paths that aren't optimal by changing the weight.
            The weight limits the worst case length of the path,
            e.g. a weight of 110% will find a path no more than 10% longer than the shortest possible.
            The benefit of allowing the search to return suboptimal paths is faster computation time.
            The search can skip some areas of the search space, meaning it has less work to do.
            </param>
            <param name="targetPredicate">Determines if the given cell is the target.</param>
            <param name="recorder">If provided, will record all nodes explored by searches performed.</param>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.CanExpand">
            <summary>
            Determines if there are more reachable cells and the search can be continued.
            If false, <see cref="M:OpenRA.Mods.Common.Pathfinder.PathSearch.Expand"/> can no longer be called.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.Expand">
            <summary>
            This function analyzes the neighbors of the most promising node in the pathfinding graph
            using the A* algorithm (A-star) and returns that node.
            </summary>
            <returns>The most promising node of the iteration.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.ExpandToTarget">
            <summary>
            Expands the path search until a path is found, and returns whether a path is found successfully.
            </summary>
            <remarks>
            If the path search has previously been expanded it will only return true if a path can be found during
            *this* expansion of the search. If the search was expanded previously and the target is already
            <see cref="F:OpenRA.Mods.Common.Pathfinder.CellStatus.Closed"/> then this method will return false.
            </remarks>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.ExpandAll">
            <summary>
            Expands the path search over the whole search space.
            Returns the cells that were visited during the search.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.FindPath">
            <summary>
            Expands the path search until a path is found, and returns that path.
            Returned path is *reversed* and given target to source.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Pathfinder.PathSearch.FindBidiPath(OpenRA.Mods.Common.Pathfinder.PathSearch,OpenRA.Mods.Common.Pathfinder.PathSearch)">
            <summary>
            Expands both path searches until they intersect, and returns the path.
            Returned path is from the source of the first search to the source of the second search.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Pathfinder.SparsePathGraph">
            <summary>
            A sparse pathfinding graph that supports a search over provided cells.
            This is a classic graph that supports an arbitrary graph of nodes and edges,
            and does not require a dense grid of cells.
            Costs and any desired connections to a <see cref="T:OpenRA.Mods.Common.Traits.ICustomMovementLayer"/>
            must be provided as input.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.Scripting.ScriptEmmyTypeOverrideAttribute">
            <summary>
            Used to override the Emmy Lua type generated by the <see cref="T:OpenRA.Mods.Common.UtilityCommands.Documentation.ExtractEmmyLuaAPI"/> utility command.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Scripting.ScriptEmmyTypeOverrideAttribute.#ctor(System.String,System.String)">
            <summary>
            Used to override the Emmy Lua type generated by the <see cref="T:OpenRA.Mods.Common.UtilityCommands.Documentation.ExtractEmmyLuaAPI"/> utility command.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.TargetExtensions.RecalculateInvalidatingHiddenTargets(OpenRA.Traits.Target,OpenRA.Player)">
            <summary>
            Update (Frozen)Actor targets to account for visibility changes or actor replacement.
            If the target actor becomes hidden without a FrozenActor, the target is invalidated.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.TargetExtensions.Recalculate(OpenRA.Traits.Target,OpenRA.Player,System.Boolean@)">
            <summary>
            Update (Frozen)Actor targets to account for visibility changes or actor replacement.
            If the target actor becomes hidden without a FrozenActor, the target actor is kept
            and the actorHidden flag is set to true.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.UpdateRules.Rules.RemoveBuildingInfoAllowPlacementOnResources">
            <summary>
            Replaces the BaseAttackNotifier with a new AttackNotifier that uses the
            new attack system.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.UpdateRules.Rules.ReplaceBaseAttackNotifier">
            <summary>
            Replaces the BaseAttackNotifier with a new AttackNotifier that uses the
            new attack system.
            </summary>
        </member>
        <member name="T:OpenRA.Mods.Common.UpdateRules.UpdateRule.TopLevelNodeTransform">
            <summary>Defines a transformation that is run on each top-level node in a yaml file set.</summary>
            <returns>An enumerable of manual steps to be run by the user.</returns>
        </member>
        <member name="T:OpenRA.Mods.Common.UpdateRules.UpdateRule.ChromeNodeTransform">
            <summary>Defines a transformation that is run on each widget node in a chrome yaml file set.</summary>
            <returns>An enumerable of manual steps to be run by the user.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateUtils.LoadModYaml(OpenRA.ModData,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Loads a YamlFileSet from a list of mod files.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateUtils.LoadExternalMapYaml(OpenRA.ModData,OpenRA.MiniYamlBuilder,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Loads a YamlFileSet containing any external yaml definitions referenced by a map yaml block.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateUtils.LoadInternalMapYaml(OpenRA.ModData,OpenRA.FileSystem.IReadWritePackage,OpenRA.MiniYamlBuilder,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Loads a YamlFileSet containing any internal definitions yaml referenced by a map yaml block.
            External references or internal references to missing files are ignored.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateUtils.UpdateMap(OpenRA.ModData,OpenRA.FileSystem.IReadWritePackage,OpenRA.Mods.Common.UpdateRules.UpdateRule,System.Collections.Generic.List{System.ValueTuple{OpenRA.FileSystem.IReadWritePackage,System.String,System.Collections.Generic.List{OpenRA.MiniYamlNodeBuilder}}}@,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Run a given update rule on a map.
            The rule is only applied to internal files - external includes are assumed to be handled separately
            but are noted in the externalFilenames list for informational purposes.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.IsRemoval(OpenRA.MiniYamlNodeBuilder)">
            <summary>Checks if node is a removal (has '-' prefix).</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.RenameKey(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Renames a yaml key preserving any @suffix.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.RemoveNodes(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Removes children with keys equal to [match] or [match]@[arbitrary suffix].</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.KeyMatches(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Returns true if the node is of the form [match] or [match]@[arbitrary suffix].</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.KeyContains(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Returns true if the node is of the form [match], [match]@[arbitrary suffix] or [arbitrary suffix]@[match].</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.ChildrenMatching(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Returns children with keys equal to [match] or [match]@[arbitrary suffix].</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.UpdateRules.UpdateExtensions.ChildrenContaining(OpenRA.MiniYamlNodeBuilder,System.String,System.Boolean,System.Boolean)">
            <summary>Returns children whose keys contain 'match' (optionally in the suffix).</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.TickFacing(OpenRA.WAngle,OpenRA.WAngle,OpenRA.WAngle)">
            <summary>
            Adds step angle units to facing in the direction that takes it closer to desiredFacing.
            If facing is already within step of desiredFacing then desiredFacing is returned.
            Step is given as an integer to allow negative values (step away from the desired facing).
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.GetTurnDirection(OpenRA.WAngle,OpenRA.WAngle)">
            <summary>
            Determines whether desiredFacing is clockwise (-1) or anticlockwise (+1) of facing.
            If desiredFacing is equal to facing or directly behind facing we treat it as being anticlockwise.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.IndexFacing(OpenRA.WAngle,System.Int32)">
            <summary>
            Calculate the frame index (between 0..numFrames) that
            should be used for the given facing value.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.AngleDiffToStep(OpenRA.WAngle,System.Int32)">
            <summary>
            Returns the remainder angle after rounding to the nearest whole step / facing.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.GetInterpolatedFacingRotation(OpenRA.WAngle,System.Int32,System.Int32)">
            <summary>Returns the angle that the closest facing sprite should be rotated by to achieve the closest interpolated facing.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.QuantizeFacing(OpenRA.WAngle,System.Int32)">
            <summary>Rounds the given facing value to the nearest quantized facing.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Util.NormalizeFacing(System.Int32)">
            <summary>Wraps an arbitrary integer facing value into the range 0 - 255.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Warheads.CreateEffectWarhead.ActorTypeAtImpact(OpenRA.World,OpenRA.WPos,OpenRA.Actor)">
            <summary>Checks if there are any actors at impact position and if the warhead is valid against any of them.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Warheads.CreateEffectWarhead.IsValidAgainstTerrain(OpenRA.World,OpenRA.WPos)">
            <summary>Checks if the warhead is valid against the terrain at impact position.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Warheads.Warhead.DoImpact(OpenRA.Traits.Target@,OpenRA.GameRules.WarheadArgs)">
            <summary>Applies the warhead's effect against the target.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Warheads.Warhead.IsValidAgainst(OpenRA.Actor,OpenRA.Actor)">
            <summary>Checks if the warhead is valid against (can do something to) the actor.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.Warheads.Warhead.IsValidAgainst(OpenRA.Traits.FrozenActor,OpenRA.Actor)">
            <summary>Checks if the warhead is valid against (can do something to) the frozen actor.</summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.WithPathFrom(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Actor,System.Func{OpenRA.Actor,OpenRA.WVec[]})">
            <summary>
            Filters <paramref name="actors"/> by only returning those that can be reached as the target of a path from
            <paramref name="sourceActor"/>. Only terrain is taken into account, i.e. as if
            <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            <paramref name="targetOffsets"/> is used to define locations around each actor in <paramref name="actors"/>
            of which one must be reachable.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.WithPathFrom(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Actor)">
            <summary>
            Filters <paramref name="actors"/> by only returning those that can be reached as the target of a path from
            <paramref name="sourceActor"/>. Only terrain is taken into account, i.e. as if
            <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.ClosestToWithPathFrom(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Actor,System.Func{OpenRA.Actor,OpenRA.WVec[]})">
            <summary>
            Of <paramref name="actors"/> that can be reached as the target of a path from
            <paramref name="sourceActor"/>, returns the nearest by comparing their <see cref="P:OpenRA.Actor.CenterPosition"/>.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            <paramref name="targetOffsets"/> is used to define locations around each actor in <paramref name="actors"/>
            of which one must be reachable.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.ClosestToWithPathFrom(System.Collections.Generic.IEnumerable{OpenRA.WPos},OpenRA.Actor)">
            <summary>
            Of <paramref name="positions"/> that can be reached as the target of a path from
            <paramref name="sourceActor"/>, returns the nearest by comparing the <see cref="P:OpenRA.Actor.CenterPosition"/>.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.WithPathTo(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.World,OpenRA.WPos)">
            <summary>
            Filters <paramref name="actors"/> by only returning those where the <paramref name="targetPosition"/> can
            be reached as the target of a path from the actor. Only terrain is taken into account, i.e. as if
            <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.WithPathToAny(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.World,System.Func{OpenRA.Actor,OpenRA.WPos[]})">
            <summary>
            Filters <paramref name="actors"/> by only returning those where any of the
            <paramref name="targetPositions"/> can be reached as the target of a path from the actor.
            Returns the reachable target positions for each actor.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.WithPathTo(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Actor)">
            <summary>
            Filters <paramref name="actors"/> by only returning those where the <paramref name="targetActor"/> can be
            reached as the target of a path from the actor. Only terrain is taken into account, i.e. as if
            <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.ClosestToWithPathTo(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.World,OpenRA.WPos)">
            <summary>
            Of <paramref name="actors"/> where the <paramref name="targetPosition"/> can be reached as the target of a
            path from the actor, returns the nearest by comparing the <see cref="P:OpenRA.Actor.CenterPosition"/>.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.ClosestToWithPathToAny(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.World,System.Func{OpenRA.Actor,OpenRA.WPos[]})">
            <summary>
            Of <paramref name="actors"/> where any of the <paramref name="targetPositions"/> can be reached as the
            target of a path from the actor, returns the nearest by comparing the <see cref="P:OpenRA.Actor.CenterPosition"/>.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.ClosestToWithPathTo(System.Collections.Generic.IEnumerable{OpenRA.Actor},OpenRA.Actor)">
            <summary>
            Of <paramref name="actors"/> where the <paramref name="targetActor"/> can be reached as the target of a
            path from the actor, returns the nearest by comparing their <see cref="P:OpenRA.Actor.CenterPosition"/>.
            Only terrain is taken into account, i.e. as if <see cref="F:OpenRA.Mods.Common.Traits.BlockedByActor.None"/> was given.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.FindActorsOnLine(OpenRA.World,OpenRA.WPos,OpenRA.WPos,OpenRA.WDist,System.Boolean)">
            <summary>
            Finds all the actors of which their health radius is intersected by a line (with a definable width) between two points.
            </summary>
            <param name="world">The engine world the line intersection is to be done in.</param>
            <param name="lineStart">The position the line should start at.</param>
            <param name="lineEnd">The position the line should end at.</param>
            <param name="lineWidth">How close an actor's health radius needs to be to the line to be considered 'intersected' by the line.</param>
            <param name="onlyBlockers">If set, only considers the size of actors that have an <see cref="T:OpenRA.Mods.Common.Traits.IBlocksProjectiles"/>
            trait which may improve search performance. However does NOT filter the returned actors on this trait.</param>
            <returns>A list of all the actors intersected by the line.</returns>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.FindActorsOnCircle(OpenRA.World,OpenRA.WPos,OpenRA.WDist)">
            <summary>
            Finds all the actors of which their health radius might be intersected by a specified circle.
            </summary>
        </member>
        <member name="M:OpenRA.Mods.Common.WorldExtensions.MinimumPointLineProjection(OpenRA.WPos,OpenRA.WPos,OpenRA.WPos)">
            <summary>
            Find the point (D) on a line (A-B) that is closest to the target point (C).
            </summary>
            <param name="lineStart">The source point (tail) of the line.</param>
            <param name="lineEnd">The target point (head) of the line.</param>
            <param name="point">The target point that the minimum distance should be found to.</param>
            <returns>The WPos that is the point on the line that is closest to the target point.</returns>
        </member>
    </members>
</doc>
